{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyHLAMSA: Python Utility for Star Alleles Sequence Alignment","text":"<p>pyHLAMSA is a Python tool for handling Multiple Sequence Alignments (MSA) of genes with star alleles, specifically focusing on IMGT-HLA, IMGT-KIR, and CYP datasets. Key features include:</p> <ul> <li>MSA Download: Fetch MSAs for latest/specific versions.</li> <li>Gene and Allele Management: Add, delete, list, and select genes and alleles.</li> <li>Intron/Exon Operations: Manipulate specific intron/exon segments.</li> <li>Position and Region Selection: Choose targeted positions or regions.</li> <li>Alignment Operations: Add, view, concatenate, crop, and find differences.</li> <li>Genomic and Nucleotide Merging: Seamlessly merge sequences.</li> <li>Variant Operations: Calculate consensus, gather statistics, and perform variant-related tasks.</li> <li>Biopython Compatibility: Transform alignments into Biopython MultipleSeqAlignment.</li> <li>Format Conversion: Load and save MSAs in various formats (VCF, MSF, TXT, BAM, GFF).</li> </ul> <p>pyHLAMSA streamlines complex gene sequence analysis, offering efficient tools for researchers.</p>"},{"location":"#run-in-command-line","title":"Run in command line","text":"<p>You can simply use this package by command line.</p> <p>If you want to use more powerful function, try the APIs written in below sections.</p> <pre><code>pip3 install git+https://github.com/linnil1/pyHLAMSA\n# show help\npyhlamsa -h\n# download kir\npyhlamsa download --family kir --db-folder tmpdir/tmp_kir_db --version 2100  tmpdir/kir --include-genes KIR2DL1 KIR2DL2\n# view the msa\npyhlamsa view tmpdir/kir.KIR2DL1 --position 3-100 --include-alleles KIR2DL1*consensus KIR2DL1*063\n# save the intron1+exon1 region to kir1.*\npyhlamsa view tmpdir/kir.KIR2DL1 --region intron1 exon1 --name tmpdir/kir1 --save --bam --gff --vcf --fasta-gapless --fasta-msa\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#1-read-sequences-from-database-in-one-line","title":"1. Read sequences from database in one line","text":"<p><code>HLAmsa</code> provided a simple way to read HLA data</p> <p>It can automatically download and read the sequences</p> <pre><code>&gt;&gt;&gt; from pyhlamsa import HLAmsa\n\n&gt;&gt;&gt; hla = HLAmsa([\"A\", \"B\"], filetype=\"gen\",\n                 version=\"3470\")\n\n&gt;&gt;&gt; print(hla.list_genes())\n['A', 'B']\n\n&gt;&gt;&gt; print(hla[\"A\"])\n&lt;A gen alleles=4101 block=5UTR(301) exon1(80) intron1(130) exon2(335) intron2(273) exon3(413) intron3(666) exon4(287) intron4(119) exon5(117) intron5(444) exon6(33) intron6(143) exon7(48) intron7(170) exon8(5) 3UTR(302)&gt;\n</code></pre> <p><code>KIRmsa</code> can also read sequences of KIR</p> <pre><code>&gt;&gt;&gt; from pyhlamsa import KIRmsa\n\n# If don't specific the genes, it will read all genes.\n&gt;&gt;&gt; kir = KIRmsa(ipd_folder=\"KIR_v2100\", version=\"2100\")\n\n&gt;&gt;&gt; print(kir.list_genes())\n['KIR2DL1', 'KIR2DL2', 'KIR2DL3', 'KIR2DL4', 'KIR2DL5', 'KIR2DP1', 'KIR2DS1', 'KIR2DS2', 'KIR2DS3', 'KIR2DS4', 'KIR2DS5', 'KIR3DL1', 'KIR3DL2', 'KIR3DL3', 'KIR3DP1', 'KIR3DS1']\n\n&gt;&gt;&gt; print(kir[\"KIR2DL1\"])\n&lt;KIR2DL1 gen alleles=173 block=5UTR(268) exon1(34) intron1(964) exon2(36) intron2(728) exon3(282) intron3(1441) exon4(300) intron4(1534) exon5(294) intron5(3157) exon6(51) intron6(4270) exon7(102) intron7(462) exon8(53) intron8(98) exon9(177) 3UTR(510)&gt;\n</code></pre> <p>Kind note: In our modules, <code>exon</code> is actually CDS, so it doesn't include <code>UTR</code>.</p>"},{"location":"#2-merge-gene-and-nuc-msa-is-quiet-simple","title":"2. Merge gene and nuc MSA is quiet simple","text":"<p>This main features give us a chance to use genomic MSA and nucleotide MSA at the same time.</p> <p>The nucleotide MSA is a exon-only sequence, thus we fill the intron with <code>E</code> after merged.</p> <pre><code># merge gen and nuc sequences when loading\n&gt;&gt;&gt; hla = HLAmsa([\"A\"], filetype=[\"gen\", \"nuc\"],\n                 imgt_alignment_folder=\"alignment_v3470\")\n&gt;&gt;&gt; print(hla[\"A\"])\n&lt;A gen alleles=7349 block=5UTR(301) exon1(80) intron1(130) exon2(351) intron2(273) exon3(436) intron3(666) exon4(361) intron4(119) exon5(117) intron5(444) exon6(33) intron6(143) exon7(48) intron7(170) exon8(5) 3UTR(302)&gt;\n\n\n# or manually\n&gt;&gt;&gt; a_gen = HLAmsa(\"A\", filetype=\"gen\", \n&gt;&gt;&gt;                imgt_alignment_folder=\"alignment_v3470\")[\"A\"]\n\n&gt;&gt;&gt; print(a_gen)\n&lt;A gen alleles=4101 block=5UTR(301) exon1(80) intron1(130) exon2(335) intron2(273) exon3(413) intron3(666) exon4(287) intron4(119) exon5(117) intron5(444) exon6(33) intron6(143) exon7(48) intron7(170) exon8(5) 3UTR(302)&gt;\n\n&gt;&gt;&gt; a_nuc = HLAmsa(\"A\", filetype=\"nuc\", \n&gt;&gt;&gt;                imgt_alignment_folder=\"alignment_v3470\")[\"A\"]\n&gt;&gt;&gt; print(a_nuc)\n&lt;A nuc alleles=7353 block=exon1(80) exon2(351) exon3(436) exon4(361) exon5(117) exon6(33) exon7(48) exon8(5)&gt;\n\n&gt;&gt;&gt; a_gen = a_gen.remove('A*03:437Q')\n&gt;&gt;&gt; print(a_gen.merge_exon(a_nuc))\n&lt;A gen alleles=7349 block=5UTR(301) exon1(80) intron1(130) exon2(351) intron2(273) exon3(436) intron3(666) exon4(361) intron4(119) exon5(117) intron5(444) exon6(33) intron6(143) exon7(48) intron7(170) exon8(5) 3UTR(302)&gt;\n</code></pre>"},{"location":"#3-block-based-selection-you-can-select-any-intronexon","title":"3. Block-based selection: You can select ANY intron/exon.","text":"<pre><code># select exon2 and exon3\n&gt;&gt;&gt; exon23 = a_gen.select_exon([2,3])  # 1-base\n&gt;&gt;&gt; print(exon23)\n&lt;A nuc alleles=4100 block=exon2(335) exon3(413)&gt;\n\n\n# select exon2 + intron2 + exon3\n&gt;&gt;&gt; e2i2e3 = a_gen.select_block([3,4,5])  # 0-base\n&gt;&gt;&gt; print(e2i2e3)\n&lt;A  alleles=4100 block=exon2(335) intron2(273) exon3(413)&gt;\n</code></pre>"},{"location":"#4-easy-to-compare-alleles-select-and-print","title":"4. Easy to compare alleles: select and print","text":"<pre><code># select first 10 alleles\n&gt;&gt; exon23_10 = exon23.select_allele(exon23.get_sequence_names()[:10])\n&gt;&gt;&gt; print(exon23_10)\n&lt;A nuc alleles=10 block=exon2(335) exon3(413)&gt;\n\n# print it\n&gt;&gt;&gt; exon23_10.print_alignment()\n                  812                                                      1136\n                    |                                                         |\n A*01:01:01:01      ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC-ATCCAGA TAATGTATGG CTGCGACG-- ----------\n A*01:01:01:02N     ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC-ATCCAGA TAATGTATGG CTGCGACG-- ----------\n A*01:01:01:03      ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC-ATCCAGA TAATGTATGG CTGCGACG-- ----------\n A*01:01:01:04      ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC-ATCCAGA TAATGTATGG CTGCGACG-- ----------\n A*01:01:01:05      ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC-ATCCAGA TAATGTATGG CTGCGACG-- ----------\n A*01:01:01:06      ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC-ATCCAGA TAATGTATGG CTGCGACG-- ----------\n A*01:01:01:07      ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC-ATCCAGA TAATGTATGG CTGCGACG-- ----------\n A*01:01:01:08      ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC-ATCCAGA TAATGTATGG CTGCGACG-- ----------\n A*01:01:01:09      ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC-ATCCAGA TAATGTATGG CTGCGACG-- ----------\n A*01:01:01:10      ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC-ATCCAGA TAATGTATGG CTGCGACG-- ----------\n\n\n# using regex to select\n# \"|\" indicate the border of block, in this case, it's the border of exon2 and exon3\n&gt;&gt;&gt; exon23_1field = exon23.select_allele(r\"A\\*.*:01:01:01$\")\n&gt;&gt;&gt; exon23_1field.print_alignment_diff()\n                  812                                                      1136\n                    |                                                         |\n A*01:01:01:01      ACCGAGCGAA CCTGGGGACC CTGCGCGGCT ACTACAACCA GAGCGAGGAC G| GTTCTCACA CC.ATCCAGA TAATGTATGG CTGCGACG.. ..........\n A*02:01:01:01      ------T-G- ---------- ---------- ---------- --------C- -| --------- --.G------ GG-------- --------.. ..........\n A*03:01:01:01      ------T-G- ---------- ---------- ---------- --------C- -| --------- --.------- ---------- --------.. ..........\n A*11:01:01:01      ------T-G- ---------- ---------- ---------- ---------- -| --------- --.------- ---------- --------.. ..........\n A*23:01:01:01      ------A--- ----C---T- GC--T-C--- ---------- --------C- -| --------- --.C------ -G----T--- --------.. ..........\n A*25:01:01:01      ------A--G ----C---T- GC--T-C--- ---------- ---------- -| --------- --.------- GG-------- --------.. ..........\n A*26:01:01:01      ---------- ---------- ---------- ---------- ---------- -| --------- --.------- GG-------- --------.. ..........\n A*29:01:01:01      ---------- ---------- ---------- ---------- --------C- -| --------- --.------- -G-------- ----C---.. ..........\n A*30:01:01:01      ------T-G- ---------- ---------- ---------- --------C- -| --------- --.------- ---------- --------.. ..........\n A*32:01:01:01      ------A--G ----C---T- GC--T-C--- ---------- --------C- -| --------- --.------- -G-------- --------.. ..........\n A*33:01:01:01      ------T-G- ---------- ---------- ---------- --------C- -| --------- --.------- -G-------- --------.. ..........\n A*34:01:01:01      ------T-G- ---------- ---------- ---------- ---------- -| --------- --.------- GG-------- --------.. ..........\n A*36:01:01:01      ---------- ---------- ---------- ---------- ---------- -| --------- --.------- ---------- --------.. ..........\n A*66:01:01:01      ------T-G- ---------- ---------- ---------- ---------- -| --------- --.------- GG-------- --------.. ..........\n A*68:01:01:01      ------T-G- ---------- ---------- ---------- --------C- -| --------- --.------- -G-------- --------.. ..........\n A*69:01:01:01      ------T-G- ---------- ---------- ---------- --------C- -| --------- --.G------ GG-------- --------.. ..........\n A*74:01:01:01      ------T-G- ---------- ---------- ---------- --------C- -| --------- --.------- -G-------- --------.. ..........\n A*80:01:01:01      ---------- ---------- ---------- ---------- ---------- -| --------- --.------- ---------- --------.. ..........\n\n\n# show only variantiation\n&gt;&gt;&gt; exon23_1field.print_snv()\nTotal variantion: 71\n                         536 537  541          565 567 570          593          640          654 658          684          721      \n                           |   |    |            |   |   |            |            |            |   |            |            |      \n A*01:01:01:01      | ATTTCT   TCAC ATCCG| CCGGC CG  CGG GGA.G | ATCGCCGTGG | .G.ACACG.C | CGTGCGGTTC GACA| AGA..A GATG| CGGGCG CCGT|\n A*02:01:01:01      | ------   ---- -----| ----- --  --- ---.- | -----A---- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*03:01:01:01      | ------   ---- -----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*11:01:01:01      | ------   A--- C----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*23:01:01:01      | ------   C--- -----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*25:01:01:01      | ------   A--- C----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*26:01:01:01      | ------   A--- C----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*29:01:01:01      | -----A   C--- -----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------T ----| ---..G ----| -----A ----|\n A*30:01:01:01      | ------   C--- -----| ----- A-  T-- A--.- | -----A---- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*32:01:01:01      | ------   ---- -----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------T ----| ---..G ----| ------ ----|\n A*33:01:01:01      | -----A   C--- -----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*34:01:01:01      | ------   A--- C----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*36:01:01:01      | ------   ---- -----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..- ----| ------ ----|\n A*66:01:01:01      | ------   A--- C----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*68:01:01:01      | ------   A--- C----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*69:01:01:01      | ------   A--- C----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------- ----| ---..G ----| ------ ----|\n A*74:01:01:01      | ------   ---- -----| ----- --  --- ---.- | ---------- | .-.-----.- | ---------T ----| ---..G ----| ------ ----|\n A*80:01:01:01      | ------   ---- -----| ----- --  --- ---.- | -----A---- | .-.--T--.- | -----A---- ----| ---..G ----| ------ ----|\n</code></pre>"},{"location":"#5-some-useful-operation","title":"5. Some useful operation","text":"<pre><code># Calculate variant frequency of ( A T C G - ) per base\n&gt;&gt;&gt; print(exon23.calculate_frequency()[:10])\n[[2, 3, 0, 4095, 0], [2, 1, 4097, 0, 0], [0, 4098, 2, 0, 0], [0, 3, 4095, 2, 0], [0, 911, 3188, 0, 1], [0, 1, 4097, 1, 1], [0, 0, 1, 0, 4099], [4097, 0, 0, 2, 1], [4, 3, 4090, 3, 0], [1, 4097, 1, 1, 0]]\n\n\n# Get consensus(The largest one in frequency) among the msa\n&gt;&gt;&gt; exon23.get_consensus(include_gap=True)\n'GCTCCC-ACTCCATGAGGTATTTCTTCACATCCGTGTCCCGGCCCGGCCGCGGGGA----GCCCCGCTTCATCGCCGTGGGC-----------------------TACGTGGACG-ACACG-CAGTTCGTGCGGTTCGACAGCGACGCCGCGAGCCAGAGGATGGAGCCG--------------------CGGGCGCCGTGGATA-GAGCAGGAGGGGCCGGAGTATTGGGACCAGGAGACACGGA-------------A-TGTGAAGGCCCACTCACAGACTGACCGAGTGGACCTGGGGACCCTGCGCGGCTACTACAACCAGAGCGAGGCCGGTTCTCACACC-ATCCAGATGATGTATGGCTGCGACG--------------TGGGG-TCGGACGGGCGCTTCCTCCGCGGGTACCAGCA---GGACGCCTACGACGGCAAGGATTAC---ATCGCCCTGAAC------------------------GAGGACCTGCGCTCTTGGACCGCGGCGGAC--------ATGGCGGCTCAGATCACCAAGCGC-AAGT----GGGAGG--CGGCCC-ATGT------------------------------------------GGCGG-AGCAGTTGAGAGCCTACCTGGAGGGCACG--------TGCGTG----GAGTGGCTCCG--CAGATA-CCTGGAGAACGGGAAGGAGACGCTGCAGC-----------------GCACGG'\n\n\n# Add sequence into MSA\n# include_gap=False in get_consensus will ignore the frequency of gap. i.e. choose one of ATCG\n&gt;&gt;&gt; a_merged = hla[\"A\"]\n&gt;&gt;&gt; consensus_seq = a_merged.get_consensus(include_gap=False)\n&gt;&gt;&gt; a_merged.append(\"A*consensus\", consensus_seq)\n&gt;&gt;&gt; a_merged.fill_imcomplete(\"A*consensus\")\n\n\n# Shrink: remove gap if all bases in the column are gap\n&gt;&gt;&gt; exon23_10.shrink().print_snv()\n gDNA               200\n                    |\n A*01:01:01:01      AAGGCCCACT CACAGACTGA CCGAGCGAAC CTGGGGACCC TGCGCGGCTA CTACAACCAG AGCGAGGACG| GTTCTCACAC CATCCAGATA ATGTATGGCT\n A*01:01:01:02N     ---------- ---------- ---------- ---------- ---------- ---------- ----------| ---------- ---------- ----------\n A*01:01:01:03      ---------- ---------- ---------- ---------- ---------- ---------- ----------| ---------- ---------- ----------\n A*01:01:01:04      ---------- ---------- ---------- ---------- ---------- ---------- ----------| ---------- ---------- ----------\n A*01:01:01:05      ---------- ---------- ---------- ---------- ---------- ---------- ----------| ---------- ---------- ----------\n A*01:01:01:06      ---------- ---------- ---------- ---------- ---------- ---------- ----------| ---------- ---------- ----------\n A*01:01:01:07      ---------- ---------- ---------- ---------- ---------- ---------- ----------| ---------- ---------- ----------\n A*01:01:01:08      ---------- ---------- ---------- ---------- ---------- ---------- ----------| ---------- ---------- ----------\n A*01:01:01:09      ---------- ---------- ---------- ---------- ---------- ---------- ----------| ---------- ---------- ----------\n A*01:01:01:10      ---------- ---------- ---------- ---------- ---------- ---------- ----------| ---------- ---------- ----------\n\n\n# select specific column \n&gt;&gt;&gt; a_gen[12:100]\n&lt;A  alleles=4100 block=(88)&gt;\n\n&gt;&gt;&gt; a_gen[[12,100]].print_alignment_diff()\n gDNA               0\n                    |\n A*01:01:01:01      GG\n A*01:01:01:02N     -G\n A*01:01:01:03      GG\n A*01:01:01:04      --\n A*01:01:01:05      --\n A*01:01:01:06      --\n A*01:01:01:07      --\n A*01:01:01:08      --\n A*01:01:01:09      --\n A*01:01:01:10      --\n A*01:01:01:11      GG\n A*01:01:01:12      GG\n\n\n# concat\n&gt;&gt;&gt; print(a_gen.select_exon([2]) + a_gen.select_exon([3]))\n&lt;A nuc alleles=4100 block=exon2(335) exon3(413)&gt;\n</code></pre>"},{"location":"#6-write-and-export-the-msa","title":"6. Write and export the MSA","text":"<p>Causion: If you run <code>merge_exon</code>, or the msa is from <code>filetype=['gen', 'nuc']</code>, You should fill the <code>E</code> BEFORE save it.</p> <p>You can fill it by consensus_seq shown before.</p> <ul> <li> <p>MultipleSeqAlignment</p> <p>Transfer to MultipleSeqAlignment</p> <pre><code>&gt;&gt;&gt; print(a_gen.to_MultipleSeqAlignment())\nAlignment with 4100 rows and 3866 columns\nCAGGAGCAGAGGGGTCAGGGCGAAGTCCCAGGGCCCCAGGCGTG...AAA A*01:01:01:01\n--------------------------------------------...--- A*01:01:01:02N\nCAGGAGCAGAGGGGTCAGGGCGAAGTCCCAGGGCCCCAGGCGTG...AAA A*01:01:01:03\n--------------------------------------------...--- A*01:01:01:04\n--------------------------------------------...AAA A*01:01:01:05\n--------------------------------------------...--- A*01:01:01:06\n--------------------------------------------...AAA A*01:01:01:07\n--------------------------------------------...--- A*01:01:01:08\n--------------------------------------------...AAA A*01:01:01:09\n--------------------------------------------...--- A*01:01:01:10\nCAGGAGCAGAGGGGTCAGGGCGAAGTCCCAGGGCCCCAGGCGTG...--- A*01:01:01:11\nCAGGAGCAGAGGGGTCAGGGCGAAGTCCCAGGGCCCCAGGCGTG...AAA A*01:01:01:12\n--------------------------------------------...AAA A*01:01:01:13\n--------------------------------------------...AAA A*01:01:01:14\n--------------------------------------------...--- A*01:01:01:15\nCAGGAGCAGAGGGGTCAGGGCGAAGTCCCAGGGCCCCAGGCGTG...--- A*01:01:01:16\nCAGGAGCAGAGGGGTCAGGGCGAAGTCCCAGGGCCCCAGGCGTG...--- A*01:01:01:17\nCAGGAGCAGAGGGGTCAGGGCGAAGTCCCAGGGCCCCAGGCGTG...AAA A*01:01:01:18\n...\n--------------------------------------------...--- A*80:07\n</code></pre> </li> <li> <p>list of SeqRecord     <pre><code># Save as MSA\nSeqIO.write(a_gen.to_records(gap=True), \"filename.msa.fa\", \"fasta\")\n# Save as no-gapped sequences\nSeqIO.write(a_gen.to_records(gap=False), \"filename.fa\", \"fasta\")\n</code></pre></p> </li> <li> <p>fasta     <pre><code>a_gen.to_fasta(\"filename.msa.fa\", gap=True)\na_gen.to_fasta(\"filename.fa\", gap=False)\n</code></pre></p> </li> <li> <p>bam     <pre><code>a_gen.to_bam(\"filename.bam\")\n</code></pre></p> </li> <li> <p>gff     <pre><code>a_gen.to_gff(\"filename.gff\")\n</code></pre></p> <p>After save the MSA as bam and gff, you can show the alignments on IGV </p> </li> <li> <p>vcf     <pre><code>a_gen.to_vcf(\"filename.vcf.gz\")\n</code></pre></p> </li> <li> <p>IMGT MSA format (xx_gen.txt)     <pre><code>a_gen.to_imgt_alignment(\"A_gen.txt\")\na_gen.to_imgt_alignment(\"A_nuc.txt\", seq_type=\"nuc\")\n</code></pre></p> </li> <li> <p>save/load</p> <p>Save our model in fasta and json, where json contains block, index information</p> <pre><code>a_gen.save_msa(\"a_gen.fa\", \"a_gen.json\")\na_gen = Genemsa.load_msa(\"a_gen.fa\", \"a_gen.json\")\n</code></pre> </li> <li> <p>load msa from other format</p> <p>pyHLAMSA only support reading from <code>MultipleSeqAlignment</code>, which is very useful object, can be generate by reading MSA by <code>Bio.AlignIO</code>.</p> <p>Checkout https://biopython.org/wiki/AlignIO#file-formats for format supporting.</p> <p>For example <pre><code>from pyhlamsa import Genemsa\nmsa = Genemsa.from_MultipleSeqAlignment(AlignIO.read(your_data_path, your_data_format))\n</code></pre></p> </li> </ul>"},{"location":"#todo","title":"TODO","text":"<ul> <li>[x] Testing</li> <li>[x] Main function</li> <li>[x] exon-only sequence handling</li> <li>[x] Reading from file</li> <li>[x] Some useful function: <code>copy</code>, <code>remove</code>, <code>get_sequence_names</code>, <code>__len__</code>, <code>size</code>, <code>split</code>, <code>concat</code></li> <li>[x] Cannot handle pseudo exon</li> <li>[x] merge blocks and labels</li> <li>[x] Fix KIR when merge gen and nuc</li> <li>[x] Use index to trace orignal position</li> <li>[x] CYP</li> <li>[x] Set reference</li> <li>[x] Download latest version of IMGT or IPD</li> <li>[x] Remove seqtype</li> <li>[x] Split code</li> <li>[x] save to VCF</li> <li>[x] Add command line usage</li> <li>[x] Remove msaio</li> <li>[x] Rewrite gene Mixins (Too complicated)</li> <li>[x] Fix selction and removeing allele by regex</li> <li>[x] Change to ACGT order</li> <li>[x] Rename: split -&gt; split_block, remove -&gt; remove_allele</li> <li>[ ] CDS != exon, (rename it?)</li> <li>[ ] Rename: pyHLAMSA -&gt; py_star_msa (MAYBE, becuase the project is originally written for HLA)</li> </ul>"},{"location":"#requirement","title":"Requirement","text":"<ul> <li>python3.9</li> <li>biopython</li> <li>pysam</li> <li>wget</li> <li>git</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip3 install git+https://github.com/linnil1/pyHLAMSA\n# or\ngit clone https://github.com/linnil1/pyHLAMSA\npip3 install -e pyHLAMSA\n</code></pre>"},{"location":"#appendix-cyp","title":"Appendix: CYP","text":"<p>Steps:</p> <ol> <li>Download fasta from https://www.pharmvar.org/download</li> <li>unzip to <code>./pharmvar-5.1.10</code></li> <li>Read it by pyhlamsa <pre><code># 4. Read it\nfrom pyhlamsa import CYPmsa\ncyp = CYPmsa(pharmvar_folder=\"./pharmvar-5.1.10\")\n\n# 5. Test it\n&gt;&gt;&gt; print(cyp['CYP26A1'].format_variantion_base())\n\n                       6407         6448         8142\n                          |            |            |\n CYP26A1*1.001       GCGAGCGCGG | ATGTTCCGAA | TCGGGTGTGT\n CYP26A1*3.001       ---------- | -----A---- | ----------\n CYP26A1*2.001       -----A---- | ---------- | ----------\n CYP26A1*4.001       ---------- | ---------- | -----C----\n</code></pre></li> </ol>"},{"location":"#setup-document","title":"Setup Document","text":"<pre><code>pip3 install mkdocs-material mkdocstrings[python-lagacy]==0.18\nmkdocs serve\n</code></pre> <p>I use python-lagacy 0.18 because <code>inherited_members</code> is not support now</p>"},{"location":"#test","title":"Test","text":"<pre><code>pip3 install -e .\npip3 install pytest black mypy\npytest\nblack pyhlamsa\nmypy pyhlamsa\n</code></pre>"},{"location":"#tested-version","title":"Tested Version","text":"<ul> <li>CYP: 5.2.2</li> <li>HLA: 3.49.0</li> <li>KIR: 2.10.0 (The DB in 2.11.0 contains bugs in KIR2DL4/5)</li> </ul>"},{"location":"#some-qas","title":"Some QAs","text":"<p>Why not inherit Bio.AlignIO.MultipleSeqAlignment?</p> <p>The class does't support lot of functions than I expected.</p> <p>And it's tidious to overwrite most of the functions to maintain our blocks information</p> <p>Why not use numpy to save the sequence?</p> <p>Performance issue is not my bottle-neck yet.</p>"},{"location":"#citations","title":"Citations","text":"<ul> <li>HLA     Robinson J, Barker DJ, Georgiou X, Cooper MA, Flicek P, Marsh SGE: IPD-IMGT/HLA Database. Nucleic Acids Research (2020), 48:D948-55</li> <li>IMGT     Robinson J, Barker DJ, Georgiou X, Cooper MA, Flicek P, Marsh SGE     IPD-IMGT/HLA Database     Nucleic Acids Research (2020) 48:D948-55</li> <li>CYP(PharmVar)     Pharmacogene Variation Consortium (PharmVar) at www.PharmVar.org using the following references: Gaedigk et al. 2018, CPT 103(3):399-401 (PMID 29134625); Gaedigk et al. 2020, CPT 107(1):43-46 (PMID 31758698) and Gaedigk et al. 2021, CPT 110(3):542-545 (PMID 34091888)</li> <li>This github</li> </ul>"},{"location":"#document","title":"Document","text":"<p>See https://linnil1.github.io/pyHLAMSA</p> <p>Gene Module.</p> <p>All the msa operation are merged into Genemsa</p>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa","title":"<code> Genemsa            (GenemsaIO, GenemsaTextOp, GenemsaBase)         </code>","text":"<p>Genemsa: core object in pyhlamsa</p> <p>More details written in GenemsaBase</p> <p>Basic usage: <pre><code>from pyhlamsa import Genemsa\nmsa = Genemsa(\"test1\")\nmsa.set_blocks([3,7])\nmsa.assume_label(\"other\")\nmsa.append(\"A\", \"GGAGGA--CA\")\nmsa.append(\"B\", \"GGGGGAA--A\")\nmsa.print_alignment()\n                  1   4     9\n                  |   |     |\nA                 GGA|GGA--|CA\nB                 GGG|GGAA-|-A\n</code></pre></p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>class Genemsa(\n    GenemsaIO,\n    GenemsaTextOp,\n    GenemsaBase,\n):\n    \"\"\"\n    Genemsa: core object in pyhlamsa\n\n    More details written in GenemsaBase\n\n    Basic usage:\n    ``` python\n    from pyhlamsa import Genemsa\n    msa = Genemsa(\"test1\")\n    msa.set_blocks([3,7])\n    msa.assume_label(\"other\")\n    msa.append(\"A\", \"GGAGGA--CA\")\n    msa.append(\"B\", \"GGGGGAA--A\")\n    msa.print_alignment()\n                      1   4     9\n                      |   |     |\n    A                 GGA|GGA--|CA\n    B                 GGG|GGAA-|-A\n    ```\n    \"\"\"\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.__add__","title":"<code>__add__(self: ~GenemsaType, msa: ~GenemsaType) -&gt; ~GenemsaType</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def __add__(self: GenemsaType, msa: GenemsaType) -&gt; GenemsaType:\n    \"\"\"\n    Concat 2 MSA\n\n    Example:\n      &gt;&gt;&gt; print(a_gen.select_exon([2]) + a_gen.select_exon([3]))\n      &lt;A nuc alleles=4100 block=exon2(335) exon3(413)&gt;\n    \"\"\"\n    names0 = set(self.get_sequence_names())\n    names1 = set(msa.get_sequence_names())\n    if names0 != names1:\n        raise ValueError(\n            \"Can not concat because some allele is miss: \"\n            + str(names0.symmetric_difference(names1))\n        )\n    new_msa = self.copy()\n    new_msa.blocks.extend(copy.deepcopy(msa.blocks))\n    new_msa.index.extend(copy.deepcopy(msa.index))\n    for name, seq in msa.items():\n        new_msa.alleles[name] += seq\n    return new_msa\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.__getitem__","title":"<code>__getitem__(self: ~GenemsaType, index: Any = None) -&gt; ~GenemsaType</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def __getitem__(self: GenemsaType, index: Any = None) -&gt; GenemsaType:\n    \"\"\"\n    Extract the region of the sequences by index (start from 0),\n    but block information will not preserved\n\n    Example:\n      &gt;&gt;&gt; msa = Genemsa(\"A\", \"gen\")\n      &gt;&gt;&gt; msa.read_alignment_file(\"A_gen.txt\")\n      &gt;&gt;&gt; # Inspect 50-100bp in the MSA\n      &gt;&gt;&gt; extract_msa = msa[50:100]\n      &gt;&gt;&gt; print(extract_msa)\n\n      &gt;&gt;&gt; # Inspect 2nd 3rd 5th bp in the MSA\n      &gt;&gt;&gt; extract_msa = msa[[1,2,4]]\n      &gt;&gt;&gt; print(extract_msa)\n    \"\"\"\n    if not index:\n        return self.copy()\n    if not self:\n        raise ValueError(\"MSA is empty\")\n\n    # Extract specific region in alignment\n    if isinstance(index, int):\n        index = [index]\n    if isinstance(index, slice):\n        alleles = {allele: seq[index] for allele, seq in self.items()}\n        index = self.index[index]\n    elif isinstance(index, (tuple, list)):\n        alleles = {\n            allele: \"\".join([seq[i] for i in index]) for allele, seq in self.items()\n        }\n        index = [self.index[i] for i in index]\n    # Fail\n    else:\n        raise TypeError(\"Bad usage\")\n\n    new_msa = self.copy(copy_allele=False)\n    new_msa.set_blocks([len(next(iter(alleles.values())))])\n    new_msa.index = copy.deepcopy(index)\n    new_msa.extend(alleles)\n    return new_msa\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.__init__","title":"<code>__init__(self, gene_name: str = 'Unamed', alleles: dict = {}, blocks: Iterable = [], index: Iterable = [], reference: str = '')</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def __init__(\n    self,\n    gene_name: str = \"Unamed\",\n    alleles: dict[str, str] = {},\n    blocks: Iterable[BlockInfo] = [],\n    index: Iterable[IndexInfo] = [],\n    reference: str = \"\",\n):\n    \"\"\"\n    Attributes:\n        gene_name: The name of the gene\n\n        alleles: MSA data.\n\n            Allele name as the key and the sequence string as the value.\n\n\n        blocks: list of block information\n        index: list of index(position) information\n        reference: allele of the msa (Optional)\n    \"\"\"\n    self.gene_name = gene_name\n    self.alleles: dict[str, str] = {}\n    self.blocks = copy.deepcopy(list(blocks or []))  # intron exon length\n    self.index = copy.deepcopy(list(index or []))\n    self.logger = logging.getLogger(__name__)\n    self.reference = reference\n\n    if alleles:\n        self.extend(alleles)\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.__iter__","title":"<code>__iter__(self) -&gt; Iterator</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str]:\n    \"\"\"Iter allele like iter(dict)\"\"\"\n    return iter(self.alleles)\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.__len__","title":"<code>__len__(self) -&gt; int</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Get the number of alleles in the MSA\n\n    Example:\n      &gt;&gt;&gt; len(a_gen)\n      4100\n    \"\"\"\n    return len(self.alleles)\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.__repr__","title":"<code>__repr__(self) -&gt; str</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Show name, number of alleles and block infos in this MSA\"\"\"\n    block_info = \" \".join([f\"{b.name}({b.length})\" for b in self.list_blocks()])\n    return f\"&lt;{self.gene_name} alleles={len(self)} block={block_info}&gt;\"\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.append","title":"<code>append(self: ~GenemsaType, name: str, seq: str) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Add a sequence into MSA (inplace)</p> <p>Make sure the sequence length is same as in MSA</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def append(self: GenemsaType, name: str, seq: str) -&gt; GenemsaType:\n    \"\"\"\n    Add a sequence into MSA (inplace)\n\n    Make sure the sequence length is same as in MSA\n    \"\"\"\n    if len(seq) == 0:  # OK to add 0 length string\n        self.alleles[name] = seq\n        return self\n    if len(seq) != self.get_length():\n        raise ValueError(\"Length not match to alignments\")\n    if name in self:\n        raise ValueError(f\"{name} already exist\")\n\n    self.alleles[name] = seq\n    return self\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.assume_label","title":"<code>assume_label(self: ~GenemsaType, seq_type: str = 'gen') -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>It will automatically generate the block's label according on <code>seq_type</code>. (inplace)</p> <p>seq_type:   * gen: 5UTR-exon1-intron1-exon2-...-exon9-3UTR   * nuc: exon1-exon2-...-exon9   * other: block1-block2-block3-...</p> <p>!!! block_length     If manually assign the block_length, the old block will be cleared.</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def assume_label(self: GenemsaType, seq_type: str = \"gen\") -&gt; GenemsaType:\n    \"\"\"\n    It will automatically generate the block's label\n    according on `seq_type`. (inplace)\n\n    seq_type:\n      * gen: 5UTR-exon1-intron1-exon2-...-exon9-3UTR\n      * nuc: exon1-exon2-...-exon9\n      * other: block1-block2-block3-...\n\n    block_length:\n        If manually assign the block_length, the old block will be cleared.\n    \"\"\"\n    if not self.get_block_length():\n        raise ValueError(\"This msa doesn't have any blocks\")\n\n    if seq_type == \"gen\":\n        assert self.get_block_length() % 2 == 1 and self.get_block_length() &gt;= 3\n        for i, blk in enumerate(self.blocks):\n            if i == 0:\n                blk.type = \"five_prime_UTR\"\n                blk.name = \"5UTR\"\n            elif i == self.get_block_length() - 1:\n                blk.type = \"three_prime_UTR\"\n                blk.name = \"3UTR\"\n            elif i % 2:\n                blk.type = \"exon\"\n                blk.name = f\"exon{i // 2 + 1}\"\n            else:\n                blk.type = \"intron\"\n                blk.name = f\"intron{i // 2}\"\n\n    elif seq_type == \"nuc\":\n        for i, blk in enumerate(self.blocks):\n            blk.type = \"exon\"\n            blk.name = f\"exon{i+1}\"\n    else:\n        for i, blk in enumerate(self.blocks):\n            blk.type = \"gene_fragment\"\n            blk.name = f\"block{i+1}\"\n\n    # inplace to reset the index\n    self.index = self.reset_index().index\n    return self\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.calculate_frequency","title":"<code>calculate_frequency(self) -&gt; list</code>  <code>inherited</code>","text":"<p>Calculate ATCG and gap frequency of each bp in MSA</p> <p>Returns:</p> Type Description <code>frequency (list[list[int]])</code> <p>Each items contains the number of ATCG and gap.</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def calculate_frequency(self) -&gt; list[list[int]]:\n    \"\"\"\n    Calculate ATCG and gap frequency of each bp in MSA\n\n    Returns:\n      frequency (list[list[int]]):\n        Each items contains the number of ATCG and gap.\n    \"\"\"\n    freqs = []\n    for i in zip(*self.alleles.values()):\n        freqs.append(\n            [i.count(\"A\"), i.count(\"C\"), i.count(\"G\"), i.count(\"T\"), i.count(\"-\")]\n        )\n    return freqs\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.contains","title":"<code>contains(self, allele: str) -&gt; bool</code>  <code>inherited</code>","text":"<p>Implement <code>in</code> operator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; msa_a = HLAmsa(\"A\")[\"A\"]\n&gt;&gt;&gt; \"A*01:01:01:01\" in msa_a\nTrue\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def contains(self, allele: str) -&gt; bool:\n    \"\"\"\n    Implement `in` operator\n\n    Example:\n        &gt;&gt;&gt; msa_a = HLAmsa(\"A\")[\"A\"]\n        &gt;&gt;&gt; \"A*01:01:01:01\" in msa_a\n        True\n    \"\"\"\n    return allele in self.alleles\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.copy","title":"<code>copy(self: ~GenemsaType, copy_allele: bool = True) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Clone a new MSA.</p> <p>Parameters:</p> Name Type Description Default <code>copy_allele</code> <code>bool</code> <p>Copy the sequences as well</p> <code>True</code> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def copy(self: GenemsaType, copy_allele: bool = True) -&gt; GenemsaType:\n    \"\"\"\n    Clone a new MSA.\n\n    Args:\n      copy_allele: Copy the sequences as well\n    \"\"\"\n    # Child's Type\n    Genemsa = type(self)\n    new_msa = Genemsa(\n        self.gene_name,\n        blocks=self.blocks,\n        index=self.index,\n        reference=self.reference,\n        alleles=self.alleles if copy_allele else {},\n    )\n    return new_msa\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.extend","title":"<code>extend(self: ~GenemsaType, msa: Union[~GenemsaType, dict[str, str]]) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Add MSA's alleles into this MSA (inplace)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def extend(\n    self: GenemsaType, msa: Union[GenemsaType, dict[str, str]]\n) -&gt; GenemsaType:\n    \"\"\"Add MSA's alleles into this MSA (inplace)\"\"\"\n    if isinstance(msa, GenemsaBase):\n        if [b.length for b in self.list_blocks()] != [\n            b.length for b in msa.list_blocks()\n        ]:\n            raise ValueError(\"Block length is different\")\n    for name, seq in msa.items():\n        self.append(name, seq)\n    return self\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.fill_incomplete","title":"<code>fill_incomplete(self: ~GenemsaType, ref_allele: str) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Fill the <code>E</code> in exon-only sequences with ref_allele sequence (inplace)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def fill_incomplete(self: GenemsaType, ref_allele: str) -&gt; GenemsaType:\n    \"\"\"Fill the `E` in exon-only sequences with ref_allele sequence (inplace)\"\"\"\n    if ref_allele not in self:\n        raise KeyError(f\"{ref_allele} not found\")\n\n    ref_seq = self.get(ref_allele)\n    for allele, seq in self.items():\n        if \"E\" in seq:\n            # replace it\n            self.alleles[allele] = \"\".join(\n                [seq[i] if seq[i] != \"E\" else ref_seq[i] for i in range(len(seq))]\n            )\n    return self\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.format_alignment","title":"<code>format_alignment(self, **kwargs_format: Any) -&gt; Iterator</code>  <code>inherited</code>","text":"<p>Transfer MSA to string(generator) To the things in step3 and step4.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs_format</code> <code>Any</code> <ul> <li>show_position_set(set[int]): Force to show the position</li> <li>max_page_width(int): The max width of each line (Default = 140char)</li> </ul> <code>{}</code> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def format_alignment(self, **kwargs_format: Any) -&gt; Iterator[str]:\n    \"\"\"\n    Transfer MSA to string(generator)\n    To the things in step3 and step4.\n\n    Args:\n      kwargs_format:\n        * show_position_set(set[int]): Force to show the position\n        * max_page_width(int): The max width of each line (Default = 140char)\n    \"\"\"\n    if not self:\n        raise ValueError(\"MSA is empty\")\n    pages = self._format_page([self.index], **kwargs_format)\n    yield from chain.from_iterable(map(self._apply_page, pages))\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get","title":"<code>get(self, allele: str) -&gt; str</code>  <code>inherited</code>","text":"<p>Get the sequence by allele name</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get(self, allele: str) -&gt; str:\n    \"\"\"Get the sequence by allele name\"\"\"\n    return self.alleles[allele]\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_allele_or_error","title":"<code>get_allele_or_error(self, allele: str = '') -&gt; tuple</code>  <code>inherited</code>","text":"<p>Get the sequence by allele name</p> <p>Parameters:</p> Name Type Description Default <code>allele</code> <code>str</code> <p>Allele name. If not provided, reference allele are used</p> <code>''</code> <p>Returns:</p> Type Description <code>allele_name (str) and its sequence (str)</code> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_allele_or_error(self, allele: str = \"\") -&gt; tuple[str, str]:\n    \"\"\"\n    Get the sequence by allele name\n\n    Args:\n      allele (str): Allele name. If not provided, reference allele are used\n\n    Returns:\n      allele_name (str) and its sequence (str):\n    \"\"\"\n    if not allele:\n        allele = self.get_reference()[0]\n    if allele not in self:\n        raise ValueError(f\"{allele} not found\")\n    return allele, self.get(allele)\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_block","title":"<code>get_block(self, block: Union[int, str, pyhlamsa.gene.base.BlockInfo]) -&gt; BlockInfo</code>  <code>inherited</code>","text":"<p>Get block by str or id</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_block(self, block: BlockInput) -&gt; BlockInfo:\n    \"\"\"Get block by str or id\"\"\"\n    return self.blocks[self.get_block_index(block)]\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_block_index","title":"<code>get_block_index(self, block: Union[int, str, pyhlamsa.gene.base.BlockInfo]) -&gt; int</code>  <code>inherited</code>","text":"<p>Find the index of the block</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_block_index(self, block: BlockInput) -&gt; int:\n    \"\"\"Find the index of the block\"\"\"\n    if isinstance(block, str):\n        for i, b in enumerate(self.list_blocks()):\n            if b.name == block:\n                return i\n    elif isinstance(block, BlockInfo):\n        for i, b in enumerate(self.list_blocks()):\n            if b.name == block.name:\n                return i\n    elif isinstance(block, int):\n        id = block\n        if id &lt; 0:\n            id = self.get_block_length() + id\n        if 0 &lt;= id &lt; self.get_block_length():\n            return id\n    else:\n        raise NotImplementedError(f\"Type of {block} not work now\")\n    raise IndexError(f\"{block} not found or out of index\")\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_block_interval","title":"<code>get_block_interval(self, block: Union[int, str, pyhlamsa.gene.base.BlockInfo]) -&gt; tuple</code>  <code>inherited</code>","text":"<p>Calculate the start(included) and end index (excluded) of the block</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_block_interval(self, block: BlockInput) -&gt; tuple[int, int]:\n    \"\"\"Calculate the start(included) and end index (excluded) of the block\"\"\"\n    index = self.get_block_index(block)\n    start = sum(self.blocks[i].length for i in range(index))\n    return start, start + self.blocks[index].length\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_block_length","title":"<code>get_block_length(self) -&gt; int</code>  <code>inherited</code>","text":"<p>Return list of blocks</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_block_length(self) -&gt; int:\n    \"\"\"Return list of blocks\"\"\"\n    return len(self.list_blocks())\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_cigar","title":"<code>get_cigar(self, target_allele: str, ref_allele: str = '') -&gt; list</code>  <code>inherited</code>","text":"<p>Get the cigar string of target_allele from ref_allele</p> <p>If ref_allele not set, it will automatically find the reference by get_reference</p> <p>Returns:</p> Type Description <code>cigar(list[op_str, num])</code> <p>The list of operator and number of bases</p> <p>Exmaple:   <code>cigar = [(M, 1), (X, 1), (D, 2), (M, 2)]</code></p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_cigar(\n    self, target_allele: str, ref_allele: str = \"\"\n) -&gt; list[tuple[str, int]]:\n    \"\"\"\n    Get the cigar string of target_allele from ref_allele\n\n    If ref_allele not set,\n    it will automatically find the reference by get_reference\n\n    Return:\n      cigar(list[op_str, num]): The list of operator and number of bases\n    Exmaple:\n      `cigar = [(M, 1), (X, 1), (D, 2), (M, 2)]`\n    \"\"\"\n    if target_allele not in self:\n        raise KeyError(f\"{target_allele} not found\")\n    ref_allele, _ = self.get_allele_or_error(ref_allele)\n    return cigar.calculate_cigar(self.get(ref_allele), self.get(target_allele))\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_consensus","title":"<code>get_consensus(self, include_gap: bool = False) -&gt; str</code>  <code>inherited</code>","text":"<p>Generate the consensus sequence by choosing maximum frequency base</p> <p>Parameters:</p> Name Type Description Default <code>include_gap</code> <code>bool</code> <p>Allow consensus contains gap if gap is the maximum item.</p> <p>If include_gap=False and all the base on that position is gap (not shrinked before), it will warning and fill with A.</p> <p><code>E</code> will be ignored.</p> <code>False</code> <p>Examples:</p> <pre><code>a0                 CCATT-GGT--GTCGGGTTTCCAG\na1                 CCACTGGGT--ATCGGGTTTCCAG\nc2                 CAATTGGGT--GTCGGGT---AAG\nconsensus          CCATTGGGT--GTCGGGTTTCCAG\nconsensus(no-gap)  CCATTGGGTAAGTCGGGTTTCCAG\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_consensus(self, include_gap: bool = False) -&gt; str:\n    \"\"\"\n    Generate the consensus sequence by choosing maximum frequency base\n\n    Args:\n      include_gap (bool):\n        Allow consensus contains gap if gap is the maximum item.\n\n        If include_gap=False and all the base on that position is gap\n        (not shrinked before),\n        it will warning and fill with A.\n\n        `E` will be ignored.\n\n    Example:\n    ```\n    a0                 CCATT-GGT--GTCGGGTTTCCAG\n    a1                 CCACTGGGT--ATCGGGTTTCCAG\n    c2                 CAATTGGGT--GTCGGGT---AAG\n    consensus          CCATTGGGT--GTCGGGTTTCCAG\n    consensus(no-gap)  CCATTGGGTAAGTCGGGTTTCCAG\n    ```\n    \"\"\"\n    freqs = self.calculate_frequency()\n    if not include_gap:\n        if any(sum(f[:4]) == 0 for f in freqs):\n            self.logger.warning(\n                \"MSA contains gap, try .shrink() before .get_consensus()\"\n            )\n        max_ind = [max(range(4), key=lambda i: f[i]) for f in freqs]\n    else:\n        max_ind = [max(range(5), key=lambda i: f[i]) for f in freqs]\n    return \"\".join(map(lambda i: \"ACGT-\"[i], max_ind))\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_length","title":"<code>get_length(self) -&gt; int</code>  <code>inherited</code>","text":"<p>Get the length of MSA</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_length(self) -&gt; int:\n    \"\"\"Get the length of MSA\"\"\"\n    # 0 sequences is allow\n    if not self:\n        # another way to calculate length\n        return sum(i.length for i in self.list_blocks())\n    else:\n        # when extend, reference allele may not exists here\n        # return len(self.get_reference()[1])\n        return len(next(iter(self.items()))[1])\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_reference","title":"<code>get_reference(self) -&gt; tuple</code>  <code>inherited</code>","text":"<p>Get the reference in MSA, if not existed, output the first one</p> <p>Returns:</p> Type Description <code>tuple</code> <p>(allele_name, allele_seq)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_reference(self) -&gt; tuple[str, str]:\n    \"\"\"\n    Get the reference in MSA, if not existed, output the first one\n\n    Returns:\n      (allele_name, allele_seq)\n    \"\"\"\n    if self.reference in self:\n        return (self.reference, self.get(self.reference))\n    if not self:\n        raise ValueError(\"MSA is empty\")\n    self.logger.warning(\n        f\"Reference {self.reference} not existed in MSA.\"\n        \" Using the first allele instead.\"\n    )\n    allele, seq = next(iter(self.items()))\n    self.reference = allele  # set it\n    return allele, seq\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_sequence_names","title":"<code>get_sequence_names(self) -&gt; KeysView</code>  <code>inherited</code>","text":"<p>Same as list_alleles</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_sequence_names(self) -&gt; KeysView[str]:\n    \"\"\"Same as list_alleles\"\"\"\n    return self.list_alleles()\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.get_variantion_base","title":"<code>get_variantion_base(self) -&gt; list</code>  <code>inherited</code>","text":"<p>Get the base positions where variation occurs</p> <p>Examples:</p> <pre><code>msa:\n  s0: AAT\n  s1: AAC\n  s2: CAC\n&gt;&gt;&gt; msa.get_variantion_base()\n[0, 2]\n</code></pre> <p>Returns:</p> Type Description <code>positions</code> <p>Each integer represent the position of variation</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def get_variantion_base(self) -&gt; list[int]:\n    \"\"\"\n    Get the base positions where variation occurs\n\n    Example:\n      ```\n      msa:\n        s0: AAT\n        s1: AAC\n        s2: CAC\n      &gt;&gt;&gt; msa.get_variantion_base()\n      [0, 2]\n      ```\n\n    Returns:\n      positions:\n        Each integer represent the position of variation\n    \"\"\"\n    freqs = self.calculate_frequency()\n    num = len(self)\n    base = []\n    for i, freq in enumerate(freqs):\n        if num not in freq:\n            base.append(i)\n    return base\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.items","title":"<code>items(self) -&gt; Iterable</code>  <code>inherited</code>","text":"<p>list allele name along with allele sequence like dict.items()</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def items(self) -&gt; Iterable[tuple[str, str]]:\n    \"\"\"list allele name along with allele sequence like dict.items()\"\"\"\n    return self.alleles.items()\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.list_alleles","title":"<code>list_alleles(self) -&gt; KeysView</code>  <code>inherited</code>","text":"<p>List all the allele's sequence name in MSA</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a_gen.list_alleles()[:3]\n['A*01:01:01:01', 'A*01:01:01:02N', 'A*01:01:01:03']\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def list_alleles(self) -&gt; KeysView[str]:\n    \"\"\"\n    List all the allele's sequence name in MSA\n\n    Example:\n       &gt;&gt;&gt; a_gen.list_alleles()[:3]\n       ['A*01:01:01:01', 'A*01:01:01:02N', 'A*01:01:01:03']\n    \"\"\"\n    return self.alleles.keys()\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.list_blocks","title":"<code>list_blocks(self) -&gt; list</code>  <code>inherited</code>","text":"<p>Return list of blocks</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def list_blocks(self) -&gt; list[BlockInfo]:\n    \"\"\"Return list of blocks\"\"\"\n    return self.blocks\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.list_index","title":"<code>list_index(self) -&gt; list</code>  <code>inherited</code>","text":"<p>Return list of index</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def list_index(self) -&gt; list[IndexInfo]:\n    \"\"\"Return list of index\"\"\"\n    return self.index\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.merge_exon","title":"<code>merge_exon(self: ~GenemsaType, msa_nuc: ~GenemsaType) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Merge nuc MSA into gen MSA</p> <p>It's allow that nuc MSA has new allele name than gen MSA, Genemsa will add the sequence in MSA, and the intron will fill by <code>E</code></p> <p>If the exon part of gen MSA is differnet (e.g. less gapped) from nuc MSA, Genemsa will try to merge if it can</p> <p>Note that the index will be reset</p> <p>Examples:</p> <pre><code># case1\nmsa_gen:\n  1: \"AA|TT|CC\",\n  2: \"AA|TC|CC\",\nmsa_nuc:\n  3: \"TC\",\nAfter merge:\n  1: \"AA|TT|CC\",\n  2: \"AA|TC|CC\",\n  3: \"EE|TC|EE\"\n</code></pre> <pre><code># case2\nmsa_gen:\n  1: \"AA|TT|CC\",\n  2: \"AA|TC|CC\",\nmsa_nuc:\n  1: \"TT-\",\n  2: \"T-C\",\n  4: \"TTC\",\nAfter merge:\n  1: \"AA|TT-|CC\",\n  2: \"AA|T-C|CC\",\n  4: \"EE|TTC|EE\"\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def merge_exon(self: GenemsaType, msa_nuc: GenemsaType) -&gt; GenemsaType:\n    \"\"\"\n    Merge nuc MSA into gen MSA\n\n    It's allow that nuc MSA has new allele name than gen MSA,\n    Genemsa will add the sequence in MSA, and the intron will fill by `E`\n\n    If the exon part of gen MSA is differnet (e.g. less gapped) from nuc MSA,\n    Genemsa will try to merge if it can\n\n    Note that the index will be reset\n\n    Example:\n      ```\n      # case1\n      msa_gen:\n        1: \"AA|TT|CC\",\n        2: \"AA|TC|CC\",\n      msa_nuc:\n        3: \"TC\",\n      After merge:\n        1: \"AA|TT|CC\",\n        2: \"AA|TC|CC\",\n        3: \"EE|TC|EE\"\n      ```\n\n      ```\n      # case2\n      msa_gen:\n        1: \"AA|TT|CC\",\n        2: \"AA|TC|CC\",\n      msa_nuc:\n        1: \"TT-\",\n        2: \"T-C\",\n        4: \"TTC\",\n      After merge:\n        1: \"AA|TT-|CC\",\n        2: \"AA|T-C|CC\",\n        4: \"EE|TTC|EE\"\n      ```\n    \"\"\"\n    # A mapping from gen name to nuc index\n    nuc_name_index = {\n        b.name: i for i, b in enumerate(msa_nuc.list_blocks()) if b.type == \"exon\"\n    }\n\n    # check it's one-to-one mapping\n    exon_set = set(b.name for b in self.list_blocks() if b.type == \"exon\")\n    if set(nuc_name_index.keys()) != exon_set:\n        raise ValueError(\n            f\"Cannot match blocks: \" f\"gen={exon_set} nuc={nuc_name_index.keys()}\"\n        )\n\n    # create new msa and make sure the order of alleles\n    new_msa = self.copy(copy_allele=False)\n    new_msa.set_blocks([])\n    new_msa.index = []\n    new_msa.extend(\n        {\n            name: \"\"\n            for name in self.get_sequence_names() | msa_nuc.get_sequence_names()\n        }\n    )\n\n    # allele names\n    gen_names = set(self.get_sequence_names())\n    nuc_names = set(msa_nuc.get_sequence_names())\n    exclude_name: set[str] = set()\n\n    # block-wise\n    msas_gen = self.split_block()\n    msas_nuc = msa_nuc.split_block()\n    for i_gen, blk_gen in enumerate(self.blocks):\n        # intron -&gt; fill with E\n        if blk_gen.name not in nuc_name_index:\n            for name in nuc_names - gen_names:\n                msas_gen[i_gen].append(name, \"E\" * blk_gen.length)\n            new_msa += msas_gen[i_gen].remove_allele(\n                list(exclude_name), inplace=True\n            )\n        # exon -&gt; check before merge\n        else:\n            i_nuc = nuc_name_index[blk_gen.name]\n            # content change or length change\n            if msas_nuc[i_nuc].get_length() != msas_gen[i_gen].get_length() or any(\n                msas_nuc[i_nuc].get(name) != msas_gen[i_gen].get(name)\n                for name in (nuc_names &amp; gen_names)\n            ):\n                # check before merge\n                if len(gen_names - nuc_names):\n                    raise ValueError(\n                        f\"Some alleles doesn't exist in nuc MSA: \"\n                        f\"{gen_names - nuc_names}\"\n                    )\n\n                diff_name = filter(\n                    lambda name: msas_nuc[i_nuc].get(name).replace(\"-\", \"\")\n                    != msas_gen[i_gen].get(name).replace(\"-\", \"\"),\n                    gen_names,\n                )\n                diff_names = list(diff_name)\n                if diff_names:\n                    self.logger.warning(\n                        f\"Some exon sequences in gen MSA \"\n                        f\"is not same as in nuc MSA \"\n                        f\"{blk_gen.name}: {diff_names}\"\n                    )\n                    new_msa.remove_allele(diff_names)\n                    exclude_name.update(diff_names)\n            new_msa += msas_nuc[i_nuc].remove_allele(list(exclude_name))\n    return new_msa.reset_index()\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.meta_to_json","title":"<code>meta_to_json(self) -&gt; dict[str, Any]</code>  <code>inherited</code>","text":"<p>Extract all meta information about this msa into dict(json)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def meta_to_json(self) -&gt; dict[str, Any]:\n    \"\"\"Extract all meta information about this msa into dict(json)\"\"\"\n    meta = {\n        \"index\": [dataclasses.asdict(i) for i in self.index],\n        \"blocks\": [dataclasses.asdict(b) for b in self.blocks],\n        \"name\": self.gene_name,\n        \"reference\": self.reference,\n    }\n    return meta\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.print_alignment","title":"<code>print_alignment(self, **kwargs_format: Any) -&gt; None</code>  <code>inherited</code>","text":"<p>Print the MSA</p> <p>Note that the index shown on output header is 1-base absolute position.</p> <p>Also, the index is absolute index, if you you want continuous positiont, use <code>.reset_index()</code> first.</p> <ul> <li><code>*</code> indicate deletion</li> <li><code>ATCG</code> indicate the SNV</li> <li><code>E</code> indicate the null base in exon-only sequence</li> <li><code>|</code> is intron and exon boundary</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = msa.select_allele(r\"A\\*.*:01:01:01$\").select_exon([6,7])\n&gt;&gt;&gt; print(''.join(a.format_alignment()))\n# or simply use\n&gt;&gt;&gt; a.print_alignment()\n                    3166                                  3342\n                       |                                     |\n   A*01:01:01:01       ATAGAAAAGG AGGGAGTTAC ACTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n   A*02:01:01:01       ATAGAAAAGG AGGGAGCTAC TCTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n   A*03:01:01:01       ATAGAAAAGG AGGGAGTTAC ACTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n   A*11:01:01:01       ATAGAAAAGG AGGGAGTTAC ACTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n   A*23:01:01:01       ATAGAAAAGG AGGGAGCTAC TCTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n   A*25:01:01:01       ATAGAAAAGG AGGGAGCTAC TCTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def print_alignment(self, **kwargs_format: Any) -&gt; None:\n    \"\"\"\n    Print the MSA\n\n    Note that the index shown on output header is 1-base absolute position.\n\n    Also, the index is absolute index, if you you want continuous positiont,\n    use `.reset_index()` first.\n\n    * `*` indicate deletion\n    * `ATCG` indicate the SNV\n    * `E` indicate the null base in exon-only sequence\n    * `|` is intron and exon boundary\n\n    Examples:\n      &gt;&gt;&gt; a = msa.select_allele(r\"A\\\\*.*:01:01:01$\").select_exon([6,7])\n      &gt;&gt;&gt; print(''.join(a.format_alignment()))\n      # or simply use\n      &gt;&gt;&gt; a.print_alignment()\n                          3166                                  3342\n                             |                                     |\n         A*01:01:01:01       ATAGAAAAGG AGGGAGTTAC ACTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n         A*02:01:01:01       ATAGAAAAGG AGGGAGCTAC TCTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n         A*03:01:01:01       ATAGAAAAGG AGGGAGTTAC ACTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n         A*11:01:01:01       ATAGAAAAGG AGGGAGTTAC ACTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n         A*23:01:01:01       ATAGAAAAGG AGGGAGCTAC TCTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n         A*25:01:01:01       ATAGAAAAGG AGGGAGCTAC TCTCAGGCTG CAA| GCAGTGA CAGTGCCCAG\n    \"\"\"\n    page_str = self.format_alignment(**kwargs_format)\n    for i in page_str:\n        print(i, end=\"\")\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.print_alignment_diff","title":"<code>print_alignment_diff(self, ref_allele: str = '', **kwargs_format: Any) -&gt; None</code>  <code>inherited</code>","text":"<p>Print the sequences of all alleles diff from <code>ref_allele</code> sequence.</p> <p>Same as print_alignment, but once the base of alleles is same as the base in reference sequence, <code>-</code> will be used</p> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = msa.select_allele(r\"A\\*.*:01:01:01$\").select_exon([6,7])\n&gt;&gt;&gt; print(a.format_alignment_diff())\n                    3166                                  3342\n                       |                                     |\n   A*01:01:01:01       ATAGAAAAGG AGGGAGTTAC ACTCAGGCTG CAA| GCAGTGA CAGTGCC\n   A*02:01:01:01       ---------- ------C--- T--------- ---| ------- -------\n   A*03:01:01:01       ---------- ---------- ---------- ---| ------- -------\n   A*11:01:01:01       ---------- ---------- ---------- ---| ------- -------\n   A*23:01:01:01       ---------- ------C--- T--------- ---| ------- -------\n   A*25:01:01:01       ---------- ------C--- T--------- ---| ------- -------\n   A*26:01:01:01       ---------- ------C--- T--------- ---| ------- -------\n   A*29:01:01:01       ---------- ------C--- T--------- ---| ------- -------\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def print_alignment_diff(self, ref_allele: str = \"\", **kwargs_format: Any) -&gt; None:\n    \"\"\"\n    Print the sequences of all alleles diff from `ref_allele` sequence.\n\n    Same as print_alignment, but\n    once the base of alleles is same as the base in reference sequence,\n    `-` will be used\n\n    Returns:\n      str: A formatted string\n\n    Examples:\n      ```\n      &gt;&gt;&gt; a = msa.select_allele(r\"A\\\\*.*:01:01:01$\").select_exon([6,7])\n      &gt;&gt;&gt; print(a.format_alignment_diff())\n                          3166                                  3342\n                             |                                     |\n         A*01:01:01:01       ATAGAAAAGG AGGGAGTTAC ACTCAGGCTG CAA| GCAGTGA CAGTGCC\n         A*02:01:01:01       ---------- ------C--- T--------- ---| ------- -------\n         A*03:01:01:01       ---------- ---------- ---------- ---| ------- -------\n         A*11:01:01:01       ---------- ---------- ---------- ---| ------- -------\n         A*23:01:01:01       ---------- ------C--- T--------- ---| ------- -------\n         A*25:01:01:01       ---------- ------C--- T--------- ---| ------- -------\n         A*26:01:01:01       ---------- ------C--- T--------- ---| ------- -------\n         A*29:01:01:01       ---------- ------C--- T--------- ---| ------- -------\n      ```\n    \"\"\"\n    new_msa = self._calc_diff_msa(ref_allele)\n    new_msa.print_alignment(**kwargs_format)\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.print_alignment_from_center","title":"<code>print_alignment_from_center(self: ~GenemsaType, pos: Union[int, collections.abc.Iterable[int]], left: int = 5, right: int = 5, **kwargs_format: Any) -&gt; None</code>  <code>inherited</code>","text":"<p>Print all alleles sequences from the center of specific position</p> <p>Check <code>.format_alignment()</code> for output format detail</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int or list of int</code> <p>The (0-base relative) positions</p> required <code>left</code> <code>int</code> <p>How many base shall print at the left of the center</p> <code>5</code> <code>right</code> <code>int</code> <p>How many base shall print at the right of the center</p> <code>5</code> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string</p> <p>Examples:</p> <pre><code> gDNA                    3022\n                         |\n HLA-A*03:02        AGAGAAAAAT\n HLA-A*01:40        -----G----\n HLA-A*03:20        -----G----\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def print_alignment_from_center(\n    self: GenemsaType,\n    pos: Union[int, Iterable[int]],\n    left: int = 5,\n    right: int = 5,\n    **kwargs_format: Any,\n) -&gt; None:\n    \"\"\"\n    Print all alleles sequences from the center of specific position\n\n    Check `.format_alignment()` for output format detail\n\n    Args:\n      pos (int or list of int): The (0-base relative) positions\n      left (int): How many base shall print at the left of the center\n      right (int): How many base shall print at the right of the center\n\n    Returns:\n      str: A formatted string\n\n    Examples:\n        ```\n         gDNA                    3022\n                                 |\n         HLA-A*03:02        AGAGAAAAAT\n         HLA-A*01:40        -----G----\n         HLA-A*03:20        -----G----\n        ```\n    \"\"\"\n    if isinstance(pos, int):\n        want_pos = [pos]\n    else:\n        want_pos = list(pos)\n    if not want_pos:\n        return\n    new_msa = self._calc_center_msa(want_pos, left, right)\n    show_position_set = set(self.index[i].pos for i in want_pos)\n    new_msa.print_alignment(show_position_set=show_position_set, **kwargs_format)\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.print_snv","title":"<code>print_snv(self, **kwargs_format: Any) -&gt; None</code>  <code>inherited</code>","text":"<p>A handy function to show all the variation between the alleles</p> <p>Note: the <code>|</code> in the output string is NOT intron and exon boundary</p> <p>Check <code>.format_alignment()</code> for output format detail</p> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string</p> <p>Examples:</p> <pre><code>Total variantion: 71\n                        308    314          329          342    349\n                          |      |            |            |      |\n A*01:01:01:01       TGGCCGTCAT GGCGCC| CCCT CCTCCT| ACTC TCGGGGGCCC TGG\n A*02:01:01:01       ---------- ------| ---- -G----| ---- --------T- ---\n A*03:01:01:01       ---------- ------| ---- ------| ---- ---------- ---\n A*11:01:01:01       ---------- ------| ---- ------| ---- ---------- ---\n A*23:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n A*25:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n A*26:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n A*29:01:01:01       ---------- ------| ---- ------| ---- -T-------- ---\n A*30:01:01:01       ---------- ------| ---- ------| ---- ---------- ---\n A*32:01:01:01       ---------- ------| ---- ------| ---- -T-------- ---\n A*33:01:01:01       ---------- ------| ---- ------| ---- -T-------- ---\n A*34:01:01:01       -----A---- ------| ---- -G----| ---- ---------- ---\n A*36:01:01:01       ---------- ------| ---- ------| ---- ---------- ---\n A*66:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n A*68:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n A*69:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n A*74:01:01:01       ---------- ------| ---- ------| ---- -T-------- ---\n A*80:01:01:01       ---------- -C----| ---- ------| ---- ---------- ---\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def print_snv(self, **kwargs_format: Any) -&gt; None:\n    \"\"\"\n    A handy function to show all the variation between the alleles\n\n    Note: the `|` in the output string is NOT intron and exon boundary\n\n    Check `.format_alignment()` for output format detail\n\n    Returns:\n      str: A formatted string\n    Example:\n        ```\n        Total variantion: 71\n                                308    314          329          342    349\n                                  |      |            |            |      |\n         A*01:01:01:01       TGGCCGTCAT GGCGCC| CCCT CCTCCT| ACTC TCGGGGGCCC TGG\n         A*02:01:01:01       ---------- ------| ---- -G----| ---- --------T- ---\n         A*03:01:01:01       ---------- ------| ---- ------| ---- ---------- ---\n         A*11:01:01:01       ---------- ------| ---- ------| ---- ---------- ---\n         A*23:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n         A*25:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n         A*26:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n         A*29:01:01:01       ---------- ------| ---- ------| ---- -T-------- ---\n         A*30:01:01:01       ---------- ------| ---- ------| ---- ---------- ---\n         A*32:01:01:01       ---------- ------| ---- ------| ---- -T-------- ---\n         A*33:01:01:01       ---------- ------| ---- ------| ---- -T-------- ---\n         A*34:01:01:01       -----A---- ------| ---- -G----| ---- ---------- ---\n         A*36:01:01:01       ---------- ------| ---- ------| ---- ---------- ---\n         A*66:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n         A*68:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n         A*69:01:01:01       ---------- ------| ---- -G----| ---- ---------- ---\n         A*74:01:01:01       ---------- ------| ---- ------| ---- -T-------- ---\n         A*80:01:01:01       ---------- -C----| ---- ------| ---- ---------- ---\n        ```\n    \"\"\"\n    msa, grouped_bases = self._calc_snp_msa()\n    show_position_set = set(\n        self.index[i].pos for bases in grouped_bases for i in bases\n    )\n    print(f\"#Total variantion: {sum(map(len, grouped_bases))}\\n\")\n    msa = msa._calc_diff_msa()\n    msa.print_alignment(show_position_set=show_position_set, **kwargs_format)\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.remove_allele","title":"<code>remove_allele(self: ~GenemsaType, query: Union[str, collections.abc.Iterable[str]], inplace: bool = True) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Remove allele sequences by regex(when query is string) or by exactly deleting (when query is a list)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def remove_allele(\n    self: GenemsaType, query: Union[str, Iterable[str]], inplace: bool = True\n) -&gt; GenemsaType:\n    \"\"\"\n    Remove allele sequences by regex(when query is string)\n    or by exactly deleting (when query is a list)\n    \"\"\"\n    if inplace:\n        new_msa = self\n    else:\n        new_msa = self.copy()\n    if isinstance(query, str):\n        for allele in list(self):\n            if re.match(query, allele):\n                del new_msa.alleles[allele]\n    elif isinstance(query, Iterable):\n        for allele in query:\n            del new_msa.alleles[allele]\n    else:\n        raise NotImplementedError\n    return new_msa\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.reset_index","title":"<code>reset_index(self: ~GenemsaType) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Reset index: The old position information will be discard.</p> <p>Each position information will be counted from 0 and the label and name will copy from its block information</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(a.format_alignment_diff())\n                   101 103 105 107 109 111 113 115 117 119\n                     |   |   |   |   |   |   |   |   |   |\n A*01:01:01:01       G   G   T   C   C   A   C   C   G   A\n A*01:01:01:02N      -   -   -   -   -   -   -   -   -   -\n\n&gt;&gt;&gt; print(a.reset_index().format_alignment_diff())\n                    1\n                    |\n A*01:01:01:01      GGTCCACCGA\n A*01:01:01:02N     ----------\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def reset_index(self: GenemsaType) -&gt; GenemsaType:\n    \"\"\"\n    Reset index:\n    The old position information will be discard.\n\n    Each position information will be counted from 0 and\n    the label and name will copy from its block information\n\n    Example:\n    ``` python\n    &gt;&gt;&gt; print(a.format_alignment_diff())\n                       101 103 105 107 109 111 113 115 117 119\n                         |   |   |   |   |   |   |   |   |   |\n     A*01:01:01:01       G   G   T   C   C   A   C   C   G   A\n     A*01:01:01:02N      -   -   -   -   -   -   -   -   -   -\n\n    &gt;&gt;&gt; print(a.reset_index().format_alignment_diff())\n                        1\n                        |\n     A*01:01:01:01      GGTCCACCGA\n     A*01:01:01:02N     ----------\n    ```\n    \"\"\"\n    new_msa = self.copy()\n    start = 0\n    new_msa.index = []\n    for block in self.list_blocks():\n        for _ in range(block.length):\n            new_msa.index.append(\n                IndexInfo(\n                    pos=start,\n                    type=block.type,\n                    name=block.name,\n                )\n            )\n            start += 1\n    assert start == self.get_length()\n    return new_msa\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.reverse_complement","title":"<code>reverse_complement(self: ~GenemsaType) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Reverse the sequences</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def reverse_complement(self: GenemsaType) -&gt; GenemsaType:\n    \"\"\"Reverse the sequences\"\"\"\n    new_msa = self.copy(copy_allele=False)\n    new_msa.blocks = copy.deepcopy(list(reversed(self.blocks)))\n    new_msa.index = copy.deepcopy(list(reversed(self.index)))\n    new_msa.extend(\n        {allele: str(Seq(seq).reverse_complement()) for allele, seq in self.items()}\n    )\n    return new_msa\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.save_msa","title":"<code>save_msa(self, file_fasta: FileType, file_json: FileType) -&gt; None</code>  <code>inherited</code>","text":"<p>Save Genemsa to pyhlamsa format (fasta and json)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def save_msa(self, file_fasta: FileType, file_json: FileType) -&gt; None:\n    \"\"\"Save Genemsa to pyhlamsa format (fasta and json)\"\"\"\n    self.to_fasta(file_fasta, gap=True)\n    f_json, require_close = getFileHandle(file_json)\n    json.dump(self.meta_to_json(), f_json)\n    if require_close:\n        f_json.close()\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.select_allele","title":"<code>select_allele(self: ~GenemsaType, query: Union[str, collections.abc.Iterable[str]]) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Select allele name by regex(when query is string) or by exactly selecting (when query is a list)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # select allele name start with A*01:01\n&gt;&gt;&gt; msa.select_allele(r\"A\\*01:01.*\")\n&gt;&gt;&gt; # select allele by list of string\n&gt;&gt;&gt; msa.select_allele([\"A*01:01\", \"A*02:03\"])\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def select_allele(\n    self: GenemsaType, query: Union[str, Iterable[str]]\n) -&gt; GenemsaType:\n    \"\"\"\n    Select allele name by regex(when query is string)\n    or by exactly selecting (when query is a list)\n\n    Examples:\n      &gt;&gt;&gt; # select allele name start with A*01:01\n      &gt;&gt;&gt; msa.select_allele(r\"A\\\\*01:01.*\")\n      &gt;&gt;&gt; # select allele by list of string\n      &gt;&gt;&gt; msa.select_allele([\"A*01:01\", \"A*02:03\"])\n    \"\"\"\n    new_msa = self.copy(copy_allele=False)\n    if isinstance(query, str):\n        new_msa.extend(\n            {allele: seq for allele, seq in self.items() if re.match(query, allele)}\n        )\n    elif isinstance(query, Iterable):\n        new_msa.extend({allele: self.get(allele) for allele in query})\n    else:\n        raise NotImplementedError\n    return new_msa\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.select_block","title":"<code>select_block(self: ~GenemsaType, index: Iterable) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Extract blocks by index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>list of int</code> <p>Leave empty if you want all the blocks.</p> <p>Index start from 0.  e.g.</p> <ul> <li>0 for 5-UTR</li> <li>1 for exon1</li> <li>2 for intron1</li> <li>3 for exon2</li> <li>4 for 3-UTR(for two exons gene)</li> <li>-1 for last block</li> </ul> <p>or you can use list of string, it will select by block name</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; a_gen.select_block([-1])\n&lt;A  alleles=4101 block=3UTR(302)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; a_gen.select_block([2, 3])\n&lt;A  alleles=4101 block=intron1(130) exon2(335)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; a_gen.select_block([\"5UTR\", \"exon3\"])\n&lt;A  alleles=4101 block=5UTR(301) exon3(413)&gt;\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def select_block(self: GenemsaType, index: Iterable[BlockInput]) -&gt; GenemsaType:\n    \"\"\"\n    Extract blocks by index\n\n    Args:\n      index (list of int): Leave empty if you want all the blocks.\n\n        Index start from 0.  e.g.\n\n        * 0 for 5-UTR\n        * 1 for exon1\n        * 2 for intron1\n        * 3 for exon2\n        * 4 for 3-UTR(for two exons gene)\n        * -1 for last block\n\n        or you can use list of string,\n        it will select by block name\n\n    Example:\n      &gt;&gt;&gt; a_gen.select_block([-1])\n      &lt;A  alleles=4101 block=3UTR(302)&gt;\n\n      &gt;&gt;&gt; a_gen.select_block([2, 3])\n      &lt;A  alleles=4101 block=intron1(130) exon2(335)&gt;\n\n      &gt;&gt;&gt; a_gen.select_block([\"5UTR\", \"exon3\"])\n      &lt;A  alleles=4101 block=5UTR(301) exon3(413)&gt;\n    \"\"\"\n    new_msa = self.copy(copy_allele=False)\n\n    # choose block index by index\n    new_block = []\n    new_index = []\n    all_pos = []\n    index_ids = [self.get_block_index(i) for i in index]\n    for i in index_ids:\n        new_block.append(self.blocks[i])\n        start, end = self.get_block_interval(i)\n        all_pos.append((start, end))\n        new_index.extend(self.index[start:end])\n    new_msa.blocks = new_block\n    new_msa.index = new_index\n\n    # extract the sequences inside block region\n    for allele, gen_seq in self.items():\n        new_seq = \"\".join([gen_seq[start:end] for start, end in all_pos])\n        new_msa.append(allele, new_seq)\n    return new_msa.copy()\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.select_complete","title":"<code>select_complete(self: ~GenemsaType) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Select non exon-only sequences (No <code>E</code> in the sequence)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def select_complete(self: GenemsaType) -&gt; GenemsaType:\n    \"\"\"Select non exon-only sequences (No `E` in the sequence)\"\"\"\n    new_msa = self.copy(copy_allele=False)\n    new_msa.extend({allele: seq for allele, seq in self.items() if \"E\" not in seq})\n    return new_msa\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.select_exon","title":"<code>select_exon(self: ~GenemsaType, exon_index: Iterable = []) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Extract the exon by index.</p> <p>Parameters:</p> Name Type Description Default <code>exon_index</code> <code>list[str|int]</code> <p>Index start from 1. i.e.</p> <ul> <li>1 for exon1</li> <li>2 for exon2</li> </ul> <p>Leave empty if you want all the exons</p> <p>If the exon_index contains list of string, it will select by name</p> <code>[]</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a_gen.select_exon([2]))\n&lt;A gen alleles=7350 block=exon2(351)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; a_gen.select_exon([2, 3]))\n&lt;A nuc alleles=7350 block=exon2(351) exon3(436)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; a_gen.select_exon([\"exon2\", \"exon3\"]))\n&lt;A nuc alleles=7350 block=exon2(351) exon3(436)&gt;\n</code></pre> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def select_exon(\n    self: GenemsaType, exon_index: Iterable[BlockInput] = []\n) -&gt; GenemsaType:\n    \"\"\"\n    Extract the exon by index.\n\n    Args:\n      exon_index (list[str|int]): Index start from 1. i.e.\n\n        * 1 for exon1\n        * 2 for exon2\n\n        Leave empty if you want all the exons\n\n        If the exon_index contains list of string,\n        it will select by name\n\n    Example:\n      &gt;&gt;&gt; a_gen.select_exon([2]))\n      &lt;A gen alleles=7350 block=exon2(351)&gt;\n\n      &gt;&gt;&gt; a_gen.select_exon([2, 3]))\n      &lt;A nuc alleles=7350 block=exon2(351) exon3(436)&gt;\n\n      &gt;&gt;&gt; a_gen.select_exon([\"exon2\", \"exon3\"]))\n      &lt;A nuc alleles=7350 block=exon2(351) exon3(436)&gt;\n    \"\"\"\n    exons = [b for b in self.list_blocks() if b.type == \"exon\"]\n\n    # If not specific the index, extract all exons\n    exon_list: list[BlockInput] = []\n    if not exon_index:\n        exon_list = exons  # type: ignore\n    else:\n        for i in exon_index:\n            if isinstance(i, int):\n                # exon -&gt; blocks position\n                if i &lt; 1 or i &gt; len(exons):\n                    raise IndexError(f\"{i} is out of exon index\")\n                i = exons[i - 1]\n            exon_list.append(i)\n\n    # check\n    for i in exon_list:\n        block = self.get_block(i)\n        if block.type != \"exon\":\n            raise IndexError(f\"{block} is not exon: input={i}\")\n    return self.select_block(exon_list)\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.select_incomplete","title":"<code>select_incomplete(self: ~GenemsaType) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Select exon-only sequences (<code>E</code> exists in the sequence)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def select_incomplete(self: GenemsaType) -&gt; GenemsaType:\n    \"\"\"Select exon-only sequences (`E` exists in the sequence)\"\"\"\n    new_msa = self.copy(copy_allele=False)\n    new_msa.extend({allele: seq for allele, seq in self.items() if \"E\" in seq})\n    return new_msa\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.set_blocks","title":"<code>set_blocks(self: ~GenemsaType, blocks: Iterable) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Set blocks (inplace)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def set_blocks(\n    self: GenemsaType, blocks: Iterable[Union[int, BlockInfo]]\n) -&gt; GenemsaType:\n    \"\"\"Set blocks (inplace)\"\"\"\n    new_blocks = []\n    for i in blocks:\n        if isinstance(i, int):\n            new_blocks.append(BlockInfo(length=i))\n        else:\n            new_blocks.append(copy.deepcopy(i))\n\n    if len(self) and self.get_length() != sum(blk.length for blk in new_blocks):\n        raise ValueError(\"Total block length not match to alignments\")\n\n    self.blocks = new_blocks\n    return self\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.set_reference","title":"<code>set_reference(self: ~GenemsaType, allele: str) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Set the reference in msa (inplace)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def set_reference(self: GenemsaType, allele: str) -&gt; GenemsaType:\n    \"\"\"Set the reference in msa (inplace)\"\"\"\n    if allele not in self:\n        self.logger.warning(f\"Cannot find {allele} in MSA\")\n    self.reference = allele\n    return self\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.shrink","title":"<code>shrink(self: ~GenemsaType) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Remove empty base if all bases in that column is gap</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def shrink(self: GenemsaType) -&gt; GenemsaType:\n    \"\"\"Remove empty base if all bases in that column is gap\"\"\"\n    # index to delete\n    freqs = self.calculate_frequency()\n    masks = [f[4] != sum(f) for f in freqs]\n    new_msa = self.copy(copy_allele=False)\n\n    # recalcuate blocks\n    for i in range(len(self.blocks)):\n        start, end = self.get_block_interval(i)\n        new_msa.blocks[i].length = sum(masks[start:end])\n    assert sum(masks) == new_msa.get_length()\n    new_msa.index = [new_msa.index[i] for i in range(len(masks)) if masks[i]]\n\n    # remove base in allele\n    for allele, seq in self.items():\n        new_msa.append(allele, \"\".join(seq[i] for i in range(len(seq)) if masks[i]))\n\n    return new_msa\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.size","title":"<code>size(self) -&gt; tuple</code>  <code>inherited</code>","text":"<p>Get the size (num_of_allele, length_of_sequence)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def size(self) -&gt; tuple[int, int]:\n    \"\"\"Get the size (num_of_allele, length_of_sequence)\"\"\"\n    return (len(self), self.get_length())\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.sort","title":"<code>sort(self: ~GenemsaType) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Sort the allele by their sequences (inplace)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def sort(self: GenemsaType) -&gt; GenemsaType:\n    \"\"\"Sort the allele by their sequences (inplace)\"\"\"\n    self.alleles = dict(sorted(self.items(), key=lambda i: i[1]))\n    return self\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.sort_name","title":"<code>sort_name(self: ~GenemsaType) -&gt; ~GenemsaType</code>  <code>inherited</code>","text":"<p>Sort the allele by alelle name (inplace)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def sort_name(self: GenemsaType) -&gt; GenemsaType:\n    \"\"\"Sort the allele by alelle name (inplace)\"\"\"\n    self.alleles = dict(sorted(self.items(), key=lambda i: i[0]))\n    return self\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.split_block","title":"<code>split_block(self: ~GenemsaType) -&gt; list</code>  <code>inherited</code>","text":"<p>Split the msa by blocks</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def split_block(self: GenemsaType) -&gt; list[GenemsaType]:\n    \"\"\"Split the msa by blocks\"\"\"\n    return [self.select_block([i]) for i in range(len(self.list_blocks()))]\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.to_MultipleSeqAlignment","title":"<code>to_MultipleSeqAlignment(self) -&gt; MultipleSeqAlignment</code>  <code>inherited</code>","text":"<p>Transfer this object to MultipleSeqAlignment(biopython)</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def to_MultipleSeqAlignment(self) -&gt; MultipleSeqAlignment:\n    \"\"\"Transfer this object to MultipleSeqAlignment(biopython)\"\"\"\n    return MultipleSeqAlignment(\n        self.to_records(gap=True), annotations=self.meta_to_json()\n    )\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.to_bam","title":"<code>to_bam(self, fname: str, ref_allele: str = '', save_ref: bool = True) -&gt; None</code>  <code>inherited</code>","text":"<p>Save the MSA into bam</p> <p>All alleles will seen as reads aligned on <code>ref_allele</code></p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>The name of bamfile</p> required <code>ref_allele</code> <code>str</code> <p>The reference allele.   If the ref_allele is empty, the first allele will be reference.</p> <code>''</code> <code>save_ref</code> <code>bool</code> <p>The reference allele will also be saved in the bam file</p> <code>True</code> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def to_bam(self, fname: str, ref_allele: str = \"\", save_ref: bool = True) -&gt; None:\n    \"\"\"\n    Save the MSA into bam\n\n    All alleles will seen as reads aligned on `ref_allele`\n\n    Args:\n      fname (str): The name of bamfile\n      ref_allele (str): The reference allele.\n          If the ref_allele is empty, the first allele will be reference.\n      save_ref (bool): The reference allele will also be saved in the bam file\n    \"\"\"\n    ref_allele, ref_seq = self.get_allele_or_error(ref_allele)\n\n    # setup reference and header\n    header = {\n        \"HD\": {\"VN\": \"1.0\"},\n        \"SQ\": [\n            {\"LN\": len(ref_seq.replace(\"-\", \"\").replace(\"E\", \"\")), \"SN\": ref_allele}\n        ],\n    }\n\n    # write bam file\n    with pysam.AlignmentFile(fname, \"wb\", header=header) as outf:\n        for allele, seq in self.items():\n            # skip\n            if not save_ref and allele == ref_allele:\n                continue\n\n            # init bam record\n            a = pysam.AlignedSegment()\n            a.query_name = allele\n            a.query_sequence = seq.replace(\"E\", \"\").replace(\"-\", \"\")\n            a.cigar = cigar.cigar_to_pysam(self.get_cigar(allele, ref_allele))  # type: ignore\n\n            # set to default\n            a.mapping_quality = 60\n            a.reference_id = 0\n            a.reference_start = 0\n            # a.template_length = 0\n            # a.query_qualities = [30] * len(a.query_sequence)\n            # a.flag = 0\n            # a.next_reference_id = 0\n            # a.next_reference_start = 0\n            outf.write(a)\n\n    pysam.sort(\"-o\", fname, fname)  # type: ignore\n    pysam.index(fname)  # type: ignore\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.to_fasta","title":"<code>to_fasta(self, fname: FileType, gap: bool = True, ref_only: bool = False) -&gt; None</code>  <code>inherited</code>","text":"<p>Save the MSA into fasta</p> <p>Parameters:</p> Name Type Description Default <code>gap</code> <code>bool</code> <p>The sequence included gap or not</p> <code>True</code> <code>ref_only</code> <code>bool</code> <p>Save reference sequence only</p> <code>False</code> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def to_fasta(\n    self, fname: FileType, gap: bool = True, ref_only: bool = False\n) -&gt; None:\n    \"\"\"\n    Save the MSA into fasta\n\n    Args:\n        gap (bool): The sequence included gap or not\n        ref_only (bool): Save reference sequence only\n    \"\"\"\n    if ref_only:\n        msa = self.select_allele([self.get_reference()[0]])\n    else:\n        msa = self\n    SeqIO.write(msa.to_records(gap=gap), fname, \"fasta\")\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.to_gff","title":"<code>to_gff(self, fname: FileType, strand: str = '+', ref_allele: str = '', igv_show_label: bool = False, save_all: bool = False) -&gt; None</code>  <code>inherited</code>","text":"<p>Save to GFF3 format</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>The file name of gff3</p> required <code>strand</code> <code>str</code> <p>Must be \"+\" or \"-\".</p> <p>If the strand is \"-\", it will add <code>strand</code> in GFF file,   if you want to reverse the sequence, please use <code>reverse_complement</code> first.</p> <code>'+'</code> <code>ref_allele</code> <code>str</code> <p>The name of allele (Must be the same in save_bam)</p> <code>''</code> <code>igv_show_label</code> <code>bool</code> <p>If it's false, it will generate proper GFF3.   Set it for True as default for easiler label reading in IGV.</p> <code>False</code> <code>save_all</code> <code>bool</code> <p>Set it True if you want to create gff records for all alleles in msa   Note that this is not very fast.</p> <code>False</code> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def to_gff(\n    self,\n    fname: FileType,\n    strand: str = \"+\",\n    ref_allele: str = \"\",\n    igv_show_label: bool = False,\n    save_all: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save to GFF3 format\n\n    Args:\n      fname (str): The file name of gff3\n      strand (str): Must be \"+\" or \"-\".\n\n          If the strand is \"-\", it will add `strand` in GFF file,\n          if you want to reverse the sequence, please use `reverse_complement` first.\n\n      ref_allele (str): The name of allele (Must be the same in save_bam)\n      igv_show_label (bool): If it's false, it will generate proper GFF3.\n          Set it for True as default for easiler label reading in IGV.\n      save_all (bool):\n          Set it True if you want to create gff records for all alleles in msa\n          Note that this is not very fast.\n    \"\"\"\n    # TODO: should I save strand == '-' in model?\n    ref_allele = self.get_allele_or_error(ref_allele)[0]\n\n    # labels\n    if not all(b.type for b in self.blocks):\n        self.logger.warning(\n            \"You should assign block's label. (We assume seq_type='other')\"\n        )\n        self.assume_label(\"other\")\n\n    if save_all:\n        alleles = list(self.list_alleles())\n    else:\n        alleles = [ref_allele]\n\n    records = []\n    for allele in alleles:\n        self.logger.debug(f\"{allele} to gff\")\n\n        # remove gap\n        msa = self.select_allele([allele]).shrink()\n        records.extend(\n            _block_to_gff(\n                msa.blocks, allele, strand=strand, igv_show_label=igv_show_label\n            )\n        )\n\n    # save\n    f_gff, require_close = getFileHandle(fname)\n    f_gff.write(\"##gff-version 3\\n\")\n    f_gff.write(_table_to_string(records))\n    if require_close:\n        f_gff.close()\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.to_imgt_alignment","title":"<code>to_imgt_alignment(self, file: FileType, seq_type: str = 'gen', index_start_from: str = 'exon1') -&gt; None</code>  <code>inherited</code>","text":"<p>Export to IMGT-alignment-like format.</p> <p>But some features do not implemented: * AA codon position: So the values in the header always 1 * position: So the values in the header always 1</p> <p>Parameters:</p> Name Type Description Default <code>seq_type</code> <code>str</code> <p>gen or nuc format</p> <code>'gen'</code> <code>index_start_from</code> <code>str</code> <p>set the start position (1) starts from.</p> <code>'exon1'</code> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def to_imgt_alignment(\n    self,\n    file: FileType,\n    seq_type: str = \"gen\",\n    index_start_from: str = \"exon1\",\n) -&gt; None:\n    \"\"\"\n    Export to IMGT-alignment-like format.\n\n    But some features do not implemented:\n    * AA codon position: So the values in the header always 1\n    * position: So the values in the header always 1\n\n    Args:\n        seq_type: gen or nuc format\n        index_start_from: set the start position (1) starts from.\n    \"\"\"\n    # This function should be located in io_operation\n    new_msa = self._calc_imgt_alignment_msa()\n    start = new_msa.get_block_interval(index_start_from)[0]\n\n    # The position is calculated by reference sequence not MSA itself\n    ref_no_gap_pos = -1\n    seq = new_msa.get_reference()[1]\n    for i, ind in enumerate(new_msa.index):\n        if seq[i] != \".\":\n            ref_no_gap_pos += 1\n        ind.pos = ref_no_gap_pos\n\n    if seq_type == \"gen\":\n        # force modify the index\n        # IMGT ends with -1 and start with 1\n        for ind in new_msa.index:\n            ind.pos -= start - 1\n            if ind.pos &lt; 0:\n                ind.pos -= 1\n        pages = self._format_page(\n            [new_msa.index],\n            header_text_align=\"left\",\n            index_header=[\"gDNA\"],\n            show_position_when_same_value=False,\n        )\n    elif seq_type == \"nuc\":\n        fake_index = [IndexInfo(pos=0)] * len(new_msa.index)\n        pages = self._format_page(\n            [new_msa.index, fake_index],\n            header_text_align=\"left\",\n            index_header=[\"cDNA\", \"AA Codon\"],\n            show_position_when_same_value=False,\n        )\n    else:\n        raise NotImplementedError(f\"Not implement {seq_type=}\")\n\n    # write\n    txt, require_close = getFileHandle(file)\n    txt.writelines(chain.from_iterable(map(new_msa._apply_page, pages)))\n    if require_close:\n        txt.close()\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.to_records","title":"<code>to_records(self, gap: bool = True) -&gt; list[SeqRecord]</code>  <code>inherited</code>","text":"<p>Transfer MSA to list of SeqRecord.</p> <p>If the base is <code>E</code> which indicate the bases are not existed for exon-only sequence, those beses are treated as gap.</p> <p>Parameters:</p> Name Type Description Default <code>gap</code> <code>bool</code> <p>The sequence included gap or not</p> <code>True</code> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def to_records(self, gap: bool = True) -&gt; list[SeqRecord]:\n    \"\"\"\n    Transfer MSA to list of SeqRecord.\n\n    If the base is `E`\n    which indicate the bases are not existed for exon-only sequence,\n    those beses are treated as gap.\n\n    Args:\n      gap (bool): The sequence included gap or not\n    \"\"\"\n    if gap:\n        return [\n            SeqRecord(Seq(seq.replace(\"E\", \"-\")), id=allele, description=\"\")\n            for allele, seq in self.items()\n        ]\n    else:\n        return [\n            SeqRecord(\n                Seq(seq.replace(\"E\", \"\").replace(\"-\", \"\")),\n                id=allele,\n                description=\"\",\n            )\n            for allele, seq in self.items()\n        ]\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.to_vcf","title":"<code>to_vcf(self, file_vcf: str, ref_allele: str = '', save_ref: bool = True, plain_text: bool = False) -&gt; None</code>  <code>inherited</code>","text":"<p>Save Genemsa into vcf format</p> <p>It will save msa into sorted and normalized vcf file (xxx.vcf.gz) along with vcf's index (xxx.vcf.gz.tbi) (You can still output plain vcf without any manipulation by set plain_text=True)</p> <p>Note that vcf-format discard the per-base alignment especially when there are many snps/indels mixed together in that position. Also, after vcf is normalized, the msa may not be the same MSA alignment as before. (But sequences are still the same)</p> <p>Parameters:</p> Name Type Description Default <code>ref_allele</code> <code>str</code> <p>The name of reference allele. I recommend the reference allele contains no gaps.</p> <code>''</code> <code>save_ref</code> <code>bool</code> <p>The reference allele will also be saved in the vcf file</p> <code>True</code> <code>plain_text</code> <code>bool</code> <p>Disable sort vcf and index vcf</p> <code>False</code> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def to_vcf(\n    self,\n    file_vcf: str,\n    ref_allele: str = \"\",\n    save_ref: bool = True,\n    plain_text: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save Genemsa into vcf format\n\n    It will save msa into sorted and normalized vcf file (xxx.vcf.gz)\n    along with vcf's index (xxx.vcf.gz.tbi)\n    (You can still output plain vcf without any manipulation by set plain_text=True)\n\n    Note that vcf-format discard the per-base alignment especially\n    when there are many snps/indels mixed together in that position.\n    Also, after vcf is normalized, the msa may not be the same MSA alignment as before.\n    (But sequences are still the same)\n\n    Args:\n      ref_allele (str):\n        The name of reference allele.\n        I recommend the reference allele contains no gaps.\n      save_ref (bool): The reference allele will also be saved in the vcf file\n      plain_text (bool): Disable sort vcf and index vcf\n    \"\"\"\n    ref_allele, ref_seq = self.get_allele_or_error(ref_allele)\n\n    # extract all variants from all alleles\n    allele_variants = {}\n    for allele in self.list_alleles():\n        if not save_ref and allele == ref_allele:\n            continue\n        variants = vcf.extract_variants(ref_seq, self.get(allele))\n        for v in variants:\n            v.chrom = ref_allele\n        allele_variants[allele] = variants\n\n    # remove suffix\n    if file_vcf.endswith(\".vcf.gz\"):\n        basename = file_vcf[:-7]\n    elif file_vcf.endswith(\".vcf\"):\n        basename = file_vcf[:-4]\n    else:\n        basename = file_vcf\n    tmpname = f\"{basename}.tmp\"\n\n    # to vcf\n    with open(f\"{tmpname}.vcf\", \"w\") as f_vcf:\n        f_vcf.write(vcf.get_vcf_header(ref_allele, ref_seq))\n        f_vcf.write(\"\\n\")\n        f_vcf.write(_table_to_string(vcf.variants_to_table(allele_variants)))\n    if plain_text:\n        os.rename(f\"{tmpname}.vcf\", f\"{basename}.vcf\")\n        return\n\n    # sort, normalize and index\n    self.select_allele([ref_allele]).to_fasta(f\"{tmpname}.fa\", gap=False)\n    with open(f\"{tmpname}.norm.vcf.gz\", \"wb\") as f_vcf:\n        f_vcf.write(\n            bcftools.norm(  # type: ignore\n                \"-f\", f\"{tmpname}.fa\", f\"{tmpname}.vcf\", \"-O\", \"z\"\n            )\n        )\n    with open(f\"{basename}.vcf.gz\", \"wb\") as f_vcf:\n        f_vcf.write(bcftools.sort(f\"{tmpname}.norm.vcf.gz\", \"-O\", \"z\"))  # type: ignore\n    bcftools.index(f\"{basename}.vcf.gz\", \"-t\", \"-f\")  # type: ignore\n    os.remove(f\"{tmpname}.fa\")\n    os.remove(f\"{tmpname}.fa.fai\")\n    os.remove(f\"{tmpname}.vcf\")\n    os.remove(f\"{tmpname}.norm.vcf.gz\")\n</code></pre>"},{"location":"#pyhlamsa.gene.genemsa.Genemsa.truth","title":"<code>truth(self) -&gt; bool</code>  <code>inherited</code>","text":"<p>If msa has 0 alleles return False else return Implement if(self) function</p> Source code in <code>pyhlamsa/gene/genemsa.py</code> <pre><code>def truth(self) -&gt; bool:\n    \"\"\"\n    If msa has 0 alleles return False\n    else return Implement if(self) function\n    \"\"\"\n    return bool(self.alleles)\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla.HLAmsa","title":"<code> HLAmsa            (Familymsa)         </code>","text":"<p>A HLA interface.</p> <p>This module read the HLA MSA from alignments/*.txt files, which use <code>|</code> to separate the intron/exon/UTR regions, but the labels are assumed with the order: <code>5UTR exon1 intron1 exon2 ... exonN 3UTR</code></p> <p>Attributes:</p> Name Type Description <code>genes</code> <code>dict[str, Genemsa]</code> <p>The dictionary use gene_name as key and msa object as value</p> Source code in <code>pyhlamsa/gene_family/hla.py</code> <pre><code>class HLAmsa(Familymsa):\n    \"\"\"\n    A HLA interface.\n\n    This module read the HLA MSA from alignments/*.txt files,\n    which use `|` to separate the intron/exon/UTR regions, but\n    the labels are assumed with the order:\n    `5UTR exon1 intron1 exon2 ... exonN 3UTR`\n\n    Attributes:\n      genes (dict[str, Genemsa]):\n        The dictionary use gene_name as key and msa object as value\n    \"\"\"\n\n    def __init__(\n        self,\n        genes: GeneSet = None,\n        filetype: TypeSet = [\"gen\", \"nuc\"],\n        imgt_alignment_folder: str = \"\",\n        version: str = \"Latest\",\n    ):\n        \"\"\"\n        Args:\n            genes (str | list[str]): A list of genes you want to read.\n\n                Set None if you want read all gene in HLA\n\n            filetype (str | list[str] | set[str]): A list of filetype.\n\n                If both `gen` and `nuc` are given, it will merge them automatically.\n\n            imgt_alignment_folder (str): Path to your IMGT-formatted MSA alignment file\n\n                You can manually download the folder from\n                &lt;https://github.com/ANHIG/IMGTHLA/tree/Latest/alignments&gt;\n                or &lt;http://ftp.ebi.ac.uk/pub/databases/ipd/imgt/hla/&gt;\n                and unzip Alignments_Rel_3470.zip\n\n                Otherwise it will automatically download the database to\n                `imgt_alignment_folder`. Default is `./alignment_v{verion}`\n\n            version (str): IMGT version you want to download (e.g. 3470 for 3.47.0)\n\n                If `imgt_alignment_folder` is existed, this value will be ignored.\n                Use `Latest` to get latest version.\n        \"\"\"\n        if not imgt_alignment_folder:\n            imgt_alignment_folder = f\"alignment_v{version}\"\n        super().__init__(\n            genes, filetype, db_folder=imgt_alignment_folder, version=version\n        )\n\n    def _download_db(self, version: str = \"Latest\") -&gt; None:\n        \"\"\"\n        Download the IMGTHLA alignments folder to `db_folder`\n\n        I get the alignments folder from git instead of\n        &lt;http://ftp.ebi.ac.uk/pub/databases/ipd/imgt/hla/&gt;\n        for better version controlling\n        \"\"\"\n        with TemporaryDirectory() as tmp_dir:\n            self._run_shell(\n                \"git\",\n                \"clone\",\n                \"--branch\",\n                version,\n                \"--single-branch\",\n                \"https://github.com/ANHIG/IMGTHLA.git\",\n                tmp_dir,\n            )\n            self._run_shell(\"mv\", tmp_dir + \"/alignments\", self.db_folder)\n\n    def _get_name(self, search_name: str) -&gt; set[str]:\n        \"\"\"Handy function to list names from file pattern\"\"\"\n        arr_files = glob(search_name)\n        return set([f.split(\"/\")[-1].split(\"_\")[0] for f in arr_files])\n\n    def list_db_gene(self, filetype: TypeSet) -&gt; list[str]:\n        \"\"\"List the gene in folder\"\"\"\n        drb = set([\"DRB1\", \"DRB3\", \"DRB4\", \"DRB5\"])\n        if \"gen\" in filetype:\n            names = names_gen = self._get_name(f\"{self.db_folder}/*_gen.txt\") | drb\n        if \"nuc\" in filetype:\n            names = names_nuc = self._get_name(f\"{self.db_folder}/*_nuc.txt\") | drb\n        if \"gen\" in filetype and \"nuc\" in filetype:\n            names = names_gen &amp; names_nuc\n            # * E exon7 is ambiguous, exon8 is gone (Also exon8 is not pseudo exon)\n            #    &lt;E gen alleles=258 block=5UTR(301) exon1(64) intron1(130)\n            #        exon2(270) intron2(244) exon3(276) intron3(621) exon4(276)\n            #        intron4(124) exon5(117) intron5(751) exon6(33) intron6(104)\n            #        exon7(43) intron7(165) exon8(5) 3UTR(356)&gt;\n            #    &lt;E nuc alleles=262 block=exon1(64) exon2(270) exon3(276)\n            #        exon4(276) exon5(117) exon6(33) exon7(41)&gt;\n            if \"gen\" in filetype and \"nuc\" in filetype:\n                names = names - set([\"E\"])\n        return list(sorted(names))\n\n    def read_db_gene(self, gene: str, filetype: TypeSet) -&gt; Genemsa:\n        \"\"\"\n        Read `{gene}_{filetype}.txt`.\n\n        If both `gen` and `nuc` are given, it will merge them.\n        \"\"\"\n        if \"gen\" in filetype:\n            msa_gen = Genemsa.read_imgt_alignment(f\"{self.db_folder}/{gene}_gen.txt\")\n            msa_gen.gene_name = gene\n            if gene != \"P\":\n                # P: special case: has even block\n                # &lt;P gen alleles=5 block=(475) (261) (589) (276) (124) (117)\n                #                        (412) (33) (150) (48) (163) (297)&gt;\n                msa_gen.assume_label(\"gen\")\n            self.logger.debug(f\"Gen {msa_gen}\")\n        if \"nuc\" in filetype:\n            # Special Case: DRB* nuc are in DRB_nuc.txt\n            if gene.startswith(\"DRB\"):\n                msa_nuc = Genemsa.read_imgt_alignment(f\"{self.db_folder}/DRB_nuc.txt\")\n                msa_nuc = msa_nuc.select_allele(gene + \".*\")\n            else:\n                msa_nuc = Genemsa.read_imgt_alignment(\n                    f\"{self.db_folder}/{gene}_nuc.txt\"\n                )\n\n            msa_nuc.gene_name = gene\n            msa_nuc.assume_label(\"nuc\")\n            self.logger.debug(f\"Nuc {msa_nuc}\")\n\n        if \"gen\" in filetype and \"nuc\" in filetype:\n            # remove some gene\n            diff_name = list(\n                set(msa_gen.get_sequence_names()) - set(msa_nuc.get_sequence_names())\n            )\n            if diff_name:\n                self.logger.warning(\n                    f\"Remove alleles doesn't exist in gen and nuc either: {diff_name}\"\n                )\n            msa_gen = msa_gen.remove_allele(diff_name)\n\n            # merge\n            msa_merged = msa_gen.merge_exon(msa_nuc)\n            self.logger.debug(f\"Merged {msa_merged}\")\n            return msa_merged\n\n        elif \"gen\" in filetype:\n            return msa_gen\n        elif \"nuc\" in filetype:\n            return msa_nuc\n        raise ValueError(\"gen or nuc are not exist in filetype\")\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla.HLAmsa.__getitem__","title":"<code>__getitem__(self, index: str) -&gt; Genemsa</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene_family/hla.py</code> <pre><code>def __getitem__(self, index: str) -&gt; Genemsa:\n    \"\"\"Get specific gene's msa\"\"\"\n    return self.genes[index]\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla.HLAmsa.__init__","title":"<code>__init__(self, genes: Union[str, Iterable[str]] = None, filetype: Union[str, Iterable[str]] = ['gen', 'nuc'], imgt_alignment_folder: str = '', version: str = 'Latest')</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>genes</code> <code>str | list[str]</code> <p>A list of genes you want to read.</p> <p>Set None if you want read all gene in HLA</p> <code>None</code> <code>filetype</code> <code>str | list[str] | set[str]</code> <p>A list of filetype.</p> <p>If both <code>gen</code> and <code>nuc</code> are given, it will merge them automatically.</p> <code>['gen', 'nuc']</code> <code>imgt_alignment_folder</code> <code>str</code> <p>Path to your IMGT-formatted MSA alignment file</p> <p>You can manually download the folder from https://github.com/ANHIG/IMGTHLA/tree/Latest/alignments or http://ftp.ebi.ac.uk/pub/databases/ipd/imgt/hla/ and unzip Alignments_Rel_3470.zip</p> <p>Otherwise it will automatically download the database to <code>imgt_alignment_folder</code>. Default is <code>./alignment_v{verion}</code></p> <code>''</code> <code>version</code> <code>str</code> <p>IMGT version you want to download (e.g. 3470 for 3.47.0)</p> <p>If <code>imgt_alignment_folder</code> is existed, this value will be ignored. Use <code>Latest</code> to get latest version.</p> <code>'Latest'</code> Source code in <code>pyhlamsa/gene_family/hla.py</code> <pre><code>def __init__(\n    self,\n    genes: GeneSet = None,\n    filetype: TypeSet = [\"gen\", \"nuc\"],\n    imgt_alignment_folder: str = \"\",\n    version: str = \"Latest\",\n):\n    \"\"\"\n    Args:\n        genes (str | list[str]): A list of genes you want to read.\n\n            Set None if you want read all gene in HLA\n\n        filetype (str | list[str] | set[str]): A list of filetype.\n\n            If both `gen` and `nuc` are given, it will merge them automatically.\n\n        imgt_alignment_folder (str): Path to your IMGT-formatted MSA alignment file\n\n            You can manually download the folder from\n            &lt;https://github.com/ANHIG/IMGTHLA/tree/Latest/alignments&gt;\n            or &lt;http://ftp.ebi.ac.uk/pub/databases/ipd/imgt/hla/&gt;\n            and unzip Alignments_Rel_3470.zip\n\n            Otherwise it will automatically download the database to\n            `imgt_alignment_folder`. Default is `./alignment_v{verion}`\n\n        version (str): IMGT version you want to download (e.g. 3470 for 3.47.0)\n\n            If `imgt_alignment_folder` is existed, this value will be ignored.\n            Use `Latest` to get latest version.\n    \"\"\"\n    if not imgt_alignment_folder:\n        imgt_alignment_folder = f\"alignment_v{version}\"\n    super().__init__(\n        genes, filetype, db_folder=imgt_alignment_folder, version=version\n    )\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla.HLAmsa.__iter__","title":"<code>__iter__(self) -&gt; Iterable[str]</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene_family/hla.py</code> <pre><code>def __iter__(self) -&gt; Iterable[str]:\n    \"\"\"Iter gene name like iter(dict)\"\"\"\n    return iter(self.genes)\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla.HLAmsa.items","title":"<code>items(self) -&gt; Iterable[tuple[str, pyhlamsa.gene.genemsa.Genemsa]]</code>  <code>inherited</code>","text":"<p>list gene name and msa like dict.items()</p> Source code in <code>pyhlamsa/gene_family/hla.py</code> <pre><code>def items(self) -&gt; Iterable[tuple[str, Genemsa]]:\n    \"\"\"list gene name and msa like dict.items()\"\"\"\n    return self.genes.items()\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla.HLAmsa.list_db_gene","title":"<code>list_db_gene(self, filetype: Union[str, Iterable[str]]) -&gt; list</code>","text":"<p>List the gene in folder</p> Source code in <code>pyhlamsa/gene_family/hla.py</code> <pre><code>def list_db_gene(self, filetype: TypeSet) -&gt; list[str]:\n    \"\"\"List the gene in folder\"\"\"\n    drb = set([\"DRB1\", \"DRB3\", \"DRB4\", \"DRB5\"])\n    if \"gen\" in filetype:\n        names = names_gen = self._get_name(f\"{self.db_folder}/*_gen.txt\") | drb\n    if \"nuc\" in filetype:\n        names = names_nuc = self._get_name(f\"{self.db_folder}/*_nuc.txt\") | drb\n    if \"gen\" in filetype and \"nuc\" in filetype:\n        names = names_gen &amp; names_nuc\n        # * E exon7 is ambiguous, exon8 is gone (Also exon8 is not pseudo exon)\n        #    &lt;E gen alleles=258 block=5UTR(301) exon1(64) intron1(130)\n        #        exon2(270) intron2(244) exon3(276) intron3(621) exon4(276)\n        #        intron4(124) exon5(117) intron5(751) exon6(33) intron6(104)\n        #        exon7(43) intron7(165) exon8(5) 3UTR(356)&gt;\n        #    &lt;E nuc alleles=262 block=exon1(64) exon2(270) exon3(276)\n        #        exon4(276) exon5(117) exon6(33) exon7(41)&gt;\n        if \"gen\" in filetype and \"nuc\" in filetype:\n            names = names - set([\"E\"])\n    return list(sorted(names))\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla.HLAmsa.list_genes","title":"<code>list_genes(self) -&gt; list</code>  <code>inherited</code>","text":"<p>List all the gene's name in this family</p> Source code in <code>pyhlamsa/gene_family/hla.py</code> <pre><code>def list_genes(self) -&gt; list[str]:\n    \"\"\"List all the gene's name in this family\"\"\"\n    return list(self.genes.keys())\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla.HLAmsa.read_db_gene","title":"<code>read_db_gene(self, gene: str, filetype: Union[str, Iterable[str]]) -&gt; Genemsa</code>","text":"<p>Read <code>{gene}_{filetype}.txt</code>.</p> <p>If both <code>gen</code> and <code>nuc</code> are given, it will merge them.</p> Source code in <code>pyhlamsa/gene_family/hla.py</code> <pre><code>def read_db_gene(self, gene: str, filetype: TypeSet) -&gt; Genemsa:\n    \"\"\"\n    Read `{gene}_{filetype}.txt`.\n\n    If both `gen` and `nuc` are given, it will merge them.\n    \"\"\"\n    if \"gen\" in filetype:\n        msa_gen = Genemsa.read_imgt_alignment(f\"{self.db_folder}/{gene}_gen.txt\")\n        msa_gen.gene_name = gene\n        if gene != \"P\":\n            # P: special case: has even block\n            # &lt;P gen alleles=5 block=(475) (261) (589) (276) (124) (117)\n            #                        (412) (33) (150) (48) (163) (297)&gt;\n            msa_gen.assume_label(\"gen\")\n        self.logger.debug(f\"Gen {msa_gen}\")\n    if \"nuc\" in filetype:\n        # Special Case: DRB* nuc are in DRB_nuc.txt\n        if gene.startswith(\"DRB\"):\n            msa_nuc = Genemsa.read_imgt_alignment(f\"{self.db_folder}/DRB_nuc.txt\")\n            msa_nuc = msa_nuc.select_allele(gene + \".*\")\n        else:\n            msa_nuc = Genemsa.read_imgt_alignment(\n                f\"{self.db_folder}/{gene}_nuc.txt\"\n            )\n\n        msa_nuc.gene_name = gene\n        msa_nuc.assume_label(\"nuc\")\n        self.logger.debug(f\"Nuc {msa_nuc}\")\n\n    if \"gen\" in filetype and \"nuc\" in filetype:\n        # remove some gene\n        diff_name = list(\n            set(msa_gen.get_sequence_names()) - set(msa_nuc.get_sequence_names())\n        )\n        if diff_name:\n            self.logger.warning(\n                f\"Remove alleles doesn't exist in gen and nuc either: {diff_name}\"\n            )\n        msa_gen = msa_gen.remove_allele(diff_name)\n\n        # merge\n        msa_merged = msa_gen.merge_exon(msa_nuc)\n        self.logger.debug(f\"Merged {msa_merged}\")\n        return msa_merged\n\n    elif \"gen\" in filetype:\n        return msa_gen\n    elif \"nuc\" in filetype:\n        return msa_nuc\n    raise ValueError(\"gen or nuc are not exist in filetype\")\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla_ex.HLAmsaEX","title":"<code> HLAmsaEX            (Familymsa)         </code>","text":"<p>A HLA interface but read gene from MSF and read intron/exon information from hla.dat</p> <p>I think this one is more reliable</p> <p>Attributes:</p> Name Type Description <code>genes</code> <code>dict[str, Genemsa]</code> <p>The dictionary use gene_name as key and msa object as value</p> Source code in <code>pyhlamsa/gene_family/hla_ex.py</code> <pre><code>class HLAmsaEX(Familymsa):\n    \"\"\"\n    A HLA interface but read gene from MSF and\n    read intron/exon information from hla.dat\n\n    I think this one is more reliable\n\n    Attributes:\n      genes (dict[str, Genemsa]):\n        The dictionary use gene_name as key and msa object as value\n    \"\"\"\n\n    def __init__(\n        self,\n        genes: GeneSet = None,\n        filetype: TypeSet = [\"gen\", \"nuc\"],\n        imgt_folder: str = \"\",\n        version: str = \"Latest\",\n    ):\n        \"\"\"\n        Args:\n            genes (str | list[str]): A list of genes you want to read.\n\n                Set None if you want read all gene in HLA\n\n            filetype (str | list[str] | set[str]): A list of filetype.\n\n                If both `gen` and `nuc` are given, it will merge them automatically.\n\n            imgt_folder (str): Path to your IMGT/HLA root folder\n\n                You can manually download &lt;https://github.com/ANHIG/IMGTHLA/&gt; and\n                checkout to specific branch\n\n                Or it will automatically download the database with assigned `version` to\n                `imgt_folder`. Default is `./IMGT_v{verion}`\n\n            version (str): IMGT version you want to download (e.g. 3470 for 3.47.0)\n\n                If `imgt_folder` is existed, this value will be ignored.\n\n                You can use `Latest` to get the latest version\n        \"\"\"\n        if not imgt_folder:\n            imgt_folder = f\"IMGT_v{version}\"\n        super().__init__(genes, filetype, db_folder=imgt_folder, version=version)\n\n    def _download_db(self, version: str = \"Latest\") -&gt; None:\n        \"\"\"\n        Download the IMGT/HLA msf and hla.dat to folder `imgt_folder`\n        \"\"\"\n        try:\n            self._run_shell(\"git\", \"lfs\")\n        except subprocess.CalledProcessError:\n            self.logger.error(f\"git lfs not installed (Try apt install git-lfs)\")\n            exit()\n\n        self._run_shell(\n            \"git\",\n            \"clone\",\n            \"--branch\",\n            version,\n            \"--single-branch\",\n            \"https://github.com/ANHIG/IMGTHLA.git\",\n            self.db_folder,\n        )\n        self._run_shell(\"git\", \"lfs\", \"pull\", cwd=self.db_folder)\n\n    def _get_name(self, search_name: str) -&gt; set[str]:\n        \"\"\"Extract name from file pattern\"\"\"\n        arr_files = glob(search_name)\n        return set([f.split(\"/\")[-1].split(\"_\")[0] for f in arr_files])\n\n    def list_db_gene(self, filetype: TypeSet) -&gt; list[str]:\n        \"\"\"List the gene in folder\"\"\"\n        drb = set([\"DRB1\", \"DRB3\", \"DRB4\", \"DRB5\"])\n        if \"gen\" in filetype:\n            names = names_gen = self._get_name(f\"{self.db_folder}/msf/*_gen.msf\") | drb\n        if \"nuc\" in filetype:\n            names = names_nuc = self._get_name(f\"{self.db_folder}/msf/*_nuc.msf\") | drb\n        if \"gen\" in filetype and \"nuc\" in filetype:\n            # HLA-E nuc has 7 bases differences from exon7 and exon8\n            names = (names_gen &amp; names_nuc) - set(\"E\")\n        return sorted(names)\n\n    def read_db_gene(self, gene: str, filetype: TypeSet) -&gt; Genemsa:\n        \"\"\"\n        Read `msf/{gene}_{filetype}.msf` and hla.dat.\n\n        If both `gen` and `nuc` are given, it will merge them.\n        \"\"\"\n        if not hasattr(self, \"dat\"):\n            self.logger.debug(f\"Reading hla.dat\")\n            self.dat = dat.read_dat_block(f\"{self.db_folder}/hla.dat\")\n\n        if \"gen\" in filetype:\n            msa_gen = Genemsa.read_msf_file(f\"{self.db_folder}/msf/{gene}_gen.msf\")\n            msa_gen.gene_name = gene\n            msa_gen = dat.apply_dat_info_on_msa(msa_gen, self.dat, seq_type=\"gen\")\n            self.logger.debug(f\"{msa_gen}\")\n\n        if \"nuc\" in filetype:\n            # Special Case: DRB* nuc are in DRB_nuc.txt\n            if gene.startswith(\"DRB\"):\n                msa_nuc = Genemsa.read_msf_file(f\"{self.db_folder}/msf/DRB_nuc.msf\")\n                msa_nuc = msa_nuc.select_allele(gene + \".*\")\n            else:\n                msa_nuc = Genemsa.read_msf_file(f\"{self.db_folder}/msf/{gene}_nuc.msf\")\n            msa_nuc.gene_name = gene\n            msa_nuc = dat.apply_dat_info_on_msa(msa_nuc, self.dat, seq_type=\"nuc\")\n            self.logger.debug(f\"{msa_nuc}\")\n\n        if \"gen\" in filetype and \"nuc\" in filetype:\n            # remove some gen not included in nuc\n            diff_name = list(\n                set(msa_gen.get_sequence_names()) - set(msa_nuc.get_sequence_names())\n            )\n            if diff_name:\n                self.logger.warning(\n                    f\"Remove alleles existed in gen but not in nuc: {diff_name}\"\n                )\n            msa_gen = msa_gen.remove_allele(diff_name)\n\n            # merge\n            msa_merged = msa_gen.merge_exon(msa_nuc)\n            self.logger.debug(f\"{msa_merged}\")\n            return msa_merged\n        elif \"gen\" in filetype:\n            return msa_gen\n        elif \"nuc\" in filetype:\n            return msa_nuc\n        raise ValueError(\"gen or nuc are not exist in filetype\")\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla_ex.HLAmsaEX.__getitem__","title":"<code>__getitem__(self, index: str) -&gt; Genemsa</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene_family/hla_ex.py</code> <pre><code>def __getitem__(self, index: str) -&gt; Genemsa:\n    \"\"\"Get specific gene's msa\"\"\"\n    return self.genes[index]\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla_ex.HLAmsaEX.__init__","title":"<code>__init__(self, genes: Union[str, Iterable[str]] = None, filetype: Union[str, Iterable[str]] = ['gen', 'nuc'], imgt_folder: str = '', version: str = 'Latest')</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>genes</code> <code>str | list[str]</code> <p>A list of genes you want to read.</p> <p>Set None if you want read all gene in HLA</p> <code>None</code> <code>filetype</code> <code>str | list[str] | set[str]</code> <p>A list of filetype.</p> <p>If both <code>gen</code> and <code>nuc</code> are given, it will merge them automatically.</p> <code>['gen', 'nuc']</code> <code>imgt_folder</code> <code>str</code> <p>Path to your IMGT/HLA root folder</p> <p>You can manually download https://github.com/ANHIG/IMGTHLA/ and checkout to specific branch</p> <p>Or it will automatically download the database with assigned <code>version</code> to <code>imgt_folder</code>. Default is <code>./IMGT_v{verion}</code></p> <code>''</code> <code>version</code> <code>str</code> <p>IMGT version you want to download (e.g. 3470 for 3.47.0)</p> <p>If <code>imgt_folder</code> is existed, this value will be ignored.</p> <p>You can use <code>Latest</code> to get the latest version</p> <code>'Latest'</code> Source code in <code>pyhlamsa/gene_family/hla_ex.py</code> <pre><code>def __init__(\n    self,\n    genes: GeneSet = None,\n    filetype: TypeSet = [\"gen\", \"nuc\"],\n    imgt_folder: str = \"\",\n    version: str = \"Latest\",\n):\n    \"\"\"\n    Args:\n        genes (str | list[str]): A list of genes you want to read.\n\n            Set None if you want read all gene in HLA\n\n        filetype (str | list[str] | set[str]): A list of filetype.\n\n            If both `gen` and `nuc` are given, it will merge them automatically.\n\n        imgt_folder (str): Path to your IMGT/HLA root folder\n\n            You can manually download &lt;https://github.com/ANHIG/IMGTHLA/&gt; and\n            checkout to specific branch\n\n            Or it will automatically download the database with assigned `version` to\n            `imgt_folder`. Default is `./IMGT_v{verion}`\n\n        version (str): IMGT version you want to download (e.g. 3470 for 3.47.0)\n\n            If `imgt_folder` is existed, this value will be ignored.\n\n            You can use `Latest` to get the latest version\n    \"\"\"\n    if not imgt_folder:\n        imgt_folder = f\"IMGT_v{version}\"\n    super().__init__(genes, filetype, db_folder=imgt_folder, version=version)\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla_ex.HLAmsaEX.__iter__","title":"<code>__iter__(self) -&gt; Iterable[str]</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene_family/hla_ex.py</code> <pre><code>def __iter__(self) -&gt; Iterable[str]:\n    \"\"\"Iter gene name like iter(dict)\"\"\"\n    return iter(self.genes)\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla_ex.HLAmsaEX.items","title":"<code>items(self) -&gt; Iterable[tuple[str, pyhlamsa.gene.genemsa.Genemsa]]</code>  <code>inherited</code>","text":"<p>list gene name and msa like dict.items()</p> Source code in <code>pyhlamsa/gene_family/hla_ex.py</code> <pre><code>def items(self) -&gt; Iterable[tuple[str, Genemsa]]:\n    \"\"\"list gene name and msa like dict.items()\"\"\"\n    return self.genes.items()\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla_ex.HLAmsaEX.list_db_gene","title":"<code>list_db_gene(self, filetype: Union[str, Iterable[str]]) -&gt; list</code>","text":"<p>List the gene in folder</p> Source code in <code>pyhlamsa/gene_family/hla_ex.py</code> <pre><code>def list_db_gene(self, filetype: TypeSet) -&gt; list[str]:\n    \"\"\"List the gene in folder\"\"\"\n    drb = set([\"DRB1\", \"DRB3\", \"DRB4\", \"DRB5\"])\n    if \"gen\" in filetype:\n        names = names_gen = self._get_name(f\"{self.db_folder}/msf/*_gen.msf\") | drb\n    if \"nuc\" in filetype:\n        names = names_nuc = self._get_name(f\"{self.db_folder}/msf/*_nuc.msf\") | drb\n    if \"gen\" in filetype and \"nuc\" in filetype:\n        # HLA-E nuc has 7 bases differences from exon7 and exon8\n        names = (names_gen &amp; names_nuc) - set(\"E\")\n    return sorted(names)\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla_ex.HLAmsaEX.list_genes","title":"<code>list_genes(self) -&gt; list</code>  <code>inherited</code>","text":"<p>List all the gene's name in this family</p> Source code in <code>pyhlamsa/gene_family/hla_ex.py</code> <pre><code>def list_genes(self) -&gt; list[str]:\n    \"\"\"List all the gene's name in this family\"\"\"\n    return list(self.genes.keys())\n</code></pre>"},{"location":"#pyhlamsa.gene_family.hla_ex.HLAmsaEX.read_db_gene","title":"<code>read_db_gene(self, gene: str, filetype: Union[str, Iterable[str]]) -&gt; Genemsa</code>","text":"<p>Read <code>msf/{gene}_{filetype}.msf</code> and hla.dat.</p> <p>If both <code>gen</code> and <code>nuc</code> are given, it will merge them.</p> Source code in <code>pyhlamsa/gene_family/hla_ex.py</code> <pre><code>def read_db_gene(self, gene: str, filetype: TypeSet) -&gt; Genemsa:\n    \"\"\"\n    Read `msf/{gene}_{filetype}.msf` and hla.dat.\n\n    If both `gen` and `nuc` are given, it will merge them.\n    \"\"\"\n    if not hasattr(self, \"dat\"):\n        self.logger.debug(f\"Reading hla.dat\")\n        self.dat = dat.read_dat_block(f\"{self.db_folder}/hla.dat\")\n\n    if \"gen\" in filetype:\n        msa_gen = Genemsa.read_msf_file(f\"{self.db_folder}/msf/{gene}_gen.msf\")\n        msa_gen.gene_name = gene\n        msa_gen = dat.apply_dat_info_on_msa(msa_gen, self.dat, seq_type=\"gen\")\n        self.logger.debug(f\"{msa_gen}\")\n\n    if \"nuc\" in filetype:\n        # Special Case: DRB* nuc are in DRB_nuc.txt\n        if gene.startswith(\"DRB\"):\n            msa_nuc = Genemsa.read_msf_file(f\"{self.db_folder}/msf/DRB_nuc.msf\")\n            msa_nuc = msa_nuc.select_allele(gene + \".*\")\n        else:\n            msa_nuc = Genemsa.read_msf_file(f\"{self.db_folder}/msf/{gene}_nuc.msf\")\n        msa_nuc.gene_name = gene\n        msa_nuc = dat.apply_dat_info_on_msa(msa_nuc, self.dat, seq_type=\"nuc\")\n        self.logger.debug(f\"{msa_nuc}\")\n\n    if \"gen\" in filetype and \"nuc\" in filetype:\n        # remove some gen not included in nuc\n        diff_name = list(\n            set(msa_gen.get_sequence_names()) - set(msa_nuc.get_sequence_names())\n        )\n        if diff_name:\n            self.logger.warning(\n                f\"Remove alleles existed in gen but not in nuc: {diff_name}\"\n            )\n        msa_gen = msa_gen.remove_allele(diff_name)\n\n        # merge\n        msa_merged = msa_gen.merge_exon(msa_nuc)\n        self.logger.debug(f\"{msa_merged}\")\n        return msa_merged\n    elif \"gen\" in filetype:\n        return msa_gen\n    elif \"nuc\" in filetype:\n        return msa_nuc\n    raise ValueError(\"gen or nuc are not exist in filetype\")\n</code></pre>"},{"location":"#pyhlamsa.gene_family.kir.KIRmsa","title":"<code> KIRmsa            (Familymsa)         </code>","text":"<p>A KIR interface that read MSA from MSF and KIR.dat</p> <p>Attributes:</p> Name Type Description <code>genes</code> <code>dict[str, Genemsa]</code> <p>The msa object for each gene</p> Source code in <code>pyhlamsa/gene_family/kir.py</code> <pre><code>class KIRmsa(Familymsa):\n    \"\"\"\n    A KIR interface that read MSA from MSF and KIR.dat\n\n    Attributes:\n        genes (dict[str, Genemsa]): The msa object for each gene\n    \"\"\"\n\n    def __init__(\n        self,\n        genes: GeneSet = None,\n        filetype: TypeSet = [\"gen\", \"nuc\"],\n        ipd_folder: str = \"\",\n        version: str = \"Latest\",\n    ):\n        \"\"\"\n        Args:\n            genes (str | list[str]): A list of genes you want to read.\n\n                Set None if you want read all gene in HLA\n\n            filetype (str | list[str] | set[str]): A list of filetype.\n\n                If both `gen` and `nuc` are given, it will merge them automatically.\n\n            ipd_folder (str): Path to your IPD/KIR folder\n\n                You can manually download &lt;https://github.com/ANHIG/IPDKIR&gt; and\n                checkout to specific branch\n\n                Or it will automatically download the database with assigned `version` to\n                `ipd_folder`. Default is `./kIR_v{verion}`\n\n            version (str): IMGT version you want to download (2110 for version 2.11.0)\n\n                If `ipd_folder` is existed, this value will be ignored.\n\n                version='Latest' to get latest version, however sometime it cannot work\n                because database may change the format, or contains bugs\n                (e.g. 2.11.0 https://github.com/ANHIG/IPDKIR/issues/44)\n        \"\"\"\n        # Why not version 2110 -&gt; 2DL4,2DL5 has exon 4\n        if not ipd_folder:\n            ipd_folder = f\"KIR_v{version}\"\n        super().__init__(genes, filetype, db_folder=ipd_folder, version=version)\n\n    def _download_db(self, version: str = \"Latest\") -&gt; None:\n        \"\"\"\n        Download the KIR to `IPDKIR`\n        \"\"\"\n        self._run_shell(\n            \"git\",\n            \"clone\",\n            \"--branch\",\n            version,\n            \"--single-branch\",\n            \"https://github.com/ANHIG/IPDKIR\",\n            self.db_folder,\n        )\n\n    def _get_name(self, search_name: str) -&gt; set[str]:\n        \"\"\"Extract name from file pattern\"\"\"\n        arr_files = glob(search_name)\n        return set([f.split(\"/\")[-1].split(\"_\")[0] for f in arr_files])\n\n    def list_db_gene(self, filetype: TypeSet) -&gt; list[str]:\n        \"\"\"List the gene in folder\"\"\"\n        if \"gen\" in filetype:\n            names = names_gen = self._get_name(f\"{self.db_folder}/msf/*_gen.msf\")\n        if \"nuc\" in filetype:\n            # Most's of E nuc is different from dat record\n            names = names_nuc = self._get_name(f\"{self.db_folder}/msf/*_nuc.msf\")\n        if \"gen\" in filetype and \"nuc\" in filetype:\n            names = names_gen &amp; names_nuc\n        return sorted(names)\n\n    def read_db_gene(self, gene: str, filetype: TypeSet) -&gt; Genemsa:\n        \"\"\"\n        Read `{gene}_{filetype}.msf and kir.dat`.\n\n        If both `gen` and `nuc` are given, it will merge them.\n        \"\"\"\n        if not hasattr(self, \"dat\"):\n            self.logger.debug(f\"Reading kir.dat\")\n            if os.path.exists(f\"{self.db_folder}/KIR.dat\"):\n                self.dat = dat.read_dat_block(f\"{self.db_folder}/KIR.dat\")\n            else:\n                self.dat = dat.read_dat_block(f\"{self.db_folder}/kir.dat\")\n\n        if \"gen\" in filetype:\n            msa_gen = Genemsa.read_msf_file(f\"{self.db_folder}/msf/{gene}_gen.msf\")\n            msa_gen.gene_name = gene\n            msa_gen = dat.apply_dat_info_on_msa(msa_gen, self.dat, seq_type=\"gen\")\n            self.logger.debug(f\"Gen {msa_gen}\")\n\n        if \"nuc\" in filetype:\n            msa_nuc = Genemsa.read_msf_file(f\"{self.db_folder}/msf/{gene}_nuc.msf\")\n            msa_nuc.gene_name = gene\n            msa_nuc = dat.apply_dat_info_on_msa(msa_nuc, self.dat, seq_type=\"nuc\")\n            self.logger.debug(f\"Nuc {msa_nuc}\")\n\n        if \"gen\" in filetype and \"nuc\" in filetype:\n            # remove some gen not included in nuc\n            diff_name = list(\n                set(msa_gen.get_sequence_names()) - set(msa_nuc.get_sequence_names())\n            )\n            if diff_name:\n                self.logger.warning(\n                    f\"Remove alleles doesn't exist in gen and nuc either: {diff_name}\"\n                )\n            msa_gen = msa_gen.remove_allele(diff_name)\n\n            # specical case\n            # exon 3 is pseudo exon\n            # so, fill with gene's exon3\n            gene_has_pseudo_exon3 = [\n                \"KIR2DL1\",\n                \"KIR2DL2\",\n                \"KIR2DL3\",\n                \"KIR2DP1\",\n                \"KIR2DS1\",\n                \"KIR2DS2\",\n                \"KIR2DS3\",\n                \"KIR2DS4\",\n                \"KIR2DS5\",\n            ]\n            if gene in gene_has_pseudo_exon3:\n                exon3 = msa_gen.select_block([5])\n                for name in set(msa_nuc) - set(msa_gen):\n                    exon3.append(name, \"-\" * exon3.get_length())\n                msa_nuc = (\n                    msa_nuc.select_block(list(range(0, 2)))\n                    + exon3\n                    + msa_nuc.select_block(list(range(3, len(msa_nuc.blocks))))\n                )\n\n            # merge\n            msa_merged = msa_gen.merge_exon(msa_nuc)\n            self.logger.debug(f\"Merged {msa_merged}\")\n            return msa_merged\n\n        elif \"gen\" in filetype:\n            return msa_gen\n        elif \"nuc\" in filetype:\n            return msa_nuc\n        raise ValueError(\"gen or nuc are not exist in filetype\")\n</code></pre>"},{"location":"#pyhlamsa.gene_family.kir.KIRmsa.__getitem__","title":"<code>__getitem__(self, index: str) -&gt; Genemsa</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene_family/kir.py</code> <pre><code>def __getitem__(self, index: str) -&gt; Genemsa:\n    \"\"\"Get specific gene's msa\"\"\"\n    return self.genes[index]\n</code></pre>"},{"location":"#pyhlamsa.gene_family.kir.KIRmsa.__init__","title":"<code>__init__(self, genes: Union[str, Iterable[str]] = None, filetype: Union[str, Iterable[str]] = ['gen', 'nuc'], ipd_folder: str = '', version: str = 'Latest')</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>genes</code> <code>str | list[str]</code> <p>A list of genes you want to read.</p> <p>Set None if you want read all gene in HLA</p> <code>None</code> <code>filetype</code> <code>str | list[str] | set[str]</code> <p>A list of filetype.</p> <p>If both <code>gen</code> and <code>nuc</code> are given, it will merge them automatically.</p> <code>['gen', 'nuc']</code> <code>ipd_folder</code> <code>str</code> <p>Path to your IPD/KIR folder</p> <p>You can manually download https://github.com/ANHIG/IPDKIR and checkout to specific branch</p> <p>Or it will automatically download the database with assigned <code>version</code> to <code>ipd_folder</code>. Default is <code>./kIR_v{verion}</code></p> <code>''</code> <code>version</code> <code>str</code> <p>IMGT version you want to download (2110 for version 2.11.0)</p> <p>If <code>ipd_folder</code> is existed, this value will be ignored.</p> <p>version='Latest' to get latest version, however sometime it cannot work because database may change the format, or contains bugs (e.g. 2.11.0 https://github.com/ANHIG/IPDKIR/issues/44)</p> <code>'Latest'</code> Source code in <code>pyhlamsa/gene_family/kir.py</code> <pre><code>def __init__(\n    self,\n    genes: GeneSet = None,\n    filetype: TypeSet = [\"gen\", \"nuc\"],\n    ipd_folder: str = \"\",\n    version: str = \"Latest\",\n):\n    \"\"\"\n    Args:\n        genes (str | list[str]): A list of genes you want to read.\n\n            Set None if you want read all gene in HLA\n\n        filetype (str | list[str] | set[str]): A list of filetype.\n\n            If both `gen` and `nuc` are given, it will merge them automatically.\n\n        ipd_folder (str): Path to your IPD/KIR folder\n\n            You can manually download &lt;https://github.com/ANHIG/IPDKIR&gt; and\n            checkout to specific branch\n\n            Or it will automatically download the database with assigned `version` to\n            `ipd_folder`. Default is `./kIR_v{verion}`\n\n        version (str): IMGT version you want to download (2110 for version 2.11.0)\n\n            If `ipd_folder` is existed, this value will be ignored.\n\n            version='Latest' to get latest version, however sometime it cannot work\n            because database may change the format, or contains bugs\n            (e.g. 2.11.0 https://github.com/ANHIG/IPDKIR/issues/44)\n    \"\"\"\n    # Why not version 2110 -&gt; 2DL4,2DL5 has exon 4\n    if not ipd_folder:\n        ipd_folder = f\"KIR_v{version}\"\n    super().__init__(genes, filetype, db_folder=ipd_folder, version=version)\n</code></pre>"},{"location":"#pyhlamsa.gene_family.kir.KIRmsa.__iter__","title":"<code>__iter__(self) -&gt; Iterable[str]</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene_family/kir.py</code> <pre><code>def __iter__(self) -&gt; Iterable[str]:\n    \"\"\"Iter gene name like iter(dict)\"\"\"\n    return iter(self.genes)\n</code></pre>"},{"location":"#pyhlamsa.gene_family.kir.KIRmsa.items","title":"<code>items(self) -&gt; Iterable[tuple[str, pyhlamsa.gene.genemsa.Genemsa]]</code>  <code>inherited</code>","text":"<p>list gene name and msa like dict.items()</p> Source code in <code>pyhlamsa/gene_family/kir.py</code> <pre><code>def items(self) -&gt; Iterable[tuple[str, Genemsa]]:\n    \"\"\"list gene name and msa like dict.items()\"\"\"\n    return self.genes.items()\n</code></pre>"},{"location":"#pyhlamsa.gene_family.kir.KIRmsa.list_db_gene","title":"<code>list_db_gene(self, filetype: Union[str, Iterable[str]]) -&gt; list</code>","text":"<p>List the gene in folder</p> Source code in <code>pyhlamsa/gene_family/kir.py</code> <pre><code>def list_db_gene(self, filetype: TypeSet) -&gt; list[str]:\n    \"\"\"List the gene in folder\"\"\"\n    if \"gen\" in filetype:\n        names = names_gen = self._get_name(f\"{self.db_folder}/msf/*_gen.msf\")\n    if \"nuc\" in filetype:\n        # Most's of E nuc is different from dat record\n        names = names_nuc = self._get_name(f\"{self.db_folder}/msf/*_nuc.msf\")\n    if \"gen\" in filetype and \"nuc\" in filetype:\n        names = names_gen &amp; names_nuc\n    return sorted(names)\n</code></pre>"},{"location":"#pyhlamsa.gene_family.kir.KIRmsa.list_genes","title":"<code>list_genes(self) -&gt; list</code>  <code>inherited</code>","text":"<p>List all the gene's name in this family</p> Source code in <code>pyhlamsa/gene_family/kir.py</code> <pre><code>def list_genes(self) -&gt; list[str]:\n    \"\"\"List all the gene's name in this family\"\"\"\n    return list(self.genes.keys())\n</code></pre>"},{"location":"#pyhlamsa.gene_family.kir.KIRmsa.read_db_gene","title":"<code>read_db_gene(self, gene: str, filetype: Union[str, Iterable[str]]) -&gt; Genemsa</code>","text":"<p>Read <code>{gene}_{filetype}.msf and kir.dat</code>.</p> <p>If both <code>gen</code> and <code>nuc</code> are given, it will merge them.</p> Source code in <code>pyhlamsa/gene_family/kir.py</code> <pre><code>def read_db_gene(self, gene: str, filetype: TypeSet) -&gt; Genemsa:\n    \"\"\"\n    Read `{gene}_{filetype}.msf and kir.dat`.\n\n    If both `gen` and `nuc` are given, it will merge them.\n    \"\"\"\n    if not hasattr(self, \"dat\"):\n        self.logger.debug(f\"Reading kir.dat\")\n        if os.path.exists(f\"{self.db_folder}/KIR.dat\"):\n            self.dat = dat.read_dat_block(f\"{self.db_folder}/KIR.dat\")\n        else:\n            self.dat = dat.read_dat_block(f\"{self.db_folder}/kir.dat\")\n\n    if \"gen\" in filetype:\n        msa_gen = Genemsa.read_msf_file(f\"{self.db_folder}/msf/{gene}_gen.msf\")\n        msa_gen.gene_name = gene\n        msa_gen = dat.apply_dat_info_on_msa(msa_gen, self.dat, seq_type=\"gen\")\n        self.logger.debug(f\"Gen {msa_gen}\")\n\n    if \"nuc\" in filetype:\n        msa_nuc = Genemsa.read_msf_file(f\"{self.db_folder}/msf/{gene}_nuc.msf\")\n        msa_nuc.gene_name = gene\n        msa_nuc = dat.apply_dat_info_on_msa(msa_nuc, self.dat, seq_type=\"nuc\")\n        self.logger.debug(f\"Nuc {msa_nuc}\")\n\n    if \"gen\" in filetype and \"nuc\" in filetype:\n        # remove some gen not included in nuc\n        diff_name = list(\n            set(msa_gen.get_sequence_names()) - set(msa_nuc.get_sequence_names())\n        )\n        if diff_name:\n            self.logger.warning(\n                f\"Remove alleles doesn't exist in gen and nuc either: {diff_name}\"\n            )\n        msa_gen = msa_gen.remove_allele(diff_name)\n\n        # specical case\n        # exon 3 is pseudo exon\n        # so, fill with gene's exon3\n        gene_has_pseudo_exon3 = [\n            \"KIR2DL1\",\n            \"KIR2DL2\",\n            \"KIR2DL3\",\n            \"KIR2DP1\",\n            \"KIR2DS1\",\n            \"KIR2DS2\",\n            \"KIR2DS3\",\n            \"KIR2DS4\",\n            \"KIR2DS5\",\n        ]\n        if gene in gene_has_pseudo_exon3:\n            exon3 = msa_gen.select_block([5])\n            for name in set(msa_nuc) - set(msa_gen):\n                exon3.append(name, \"-\" * exon3.get_length())\n            msa_nuc = (\n                msa_nuc.select_block(list(range(0, 2)))\n                + exon3\n                + msa_nuc.select_block(list(range(3, len(msa_nuc.blocks))))\n            )\n\n        # merge\n        msa_merged = msa_gen.merge_exon(msa_nuc)\n        self.logger.debug(f\"Merged {msa_merged}\")\n        return msa_merged\n\n    elif \"gen\" in filetype:\n        return msa_gen\n    elif \"nuc\" in filetype:\n        return msa_nuc\n    raise ValueError(\"gen or nuc are not exist in filetype\")\n</code></pre>"},{"location":"#pyhlamsa.gene_family.cyp.CYPmsa","title":"<code> CYPmsa            (Familymsa)         </code>","text":"<p>A CYP interface that read MSA from fasta and haplotypes.tsv</p> <p>Attributes:</p> Name Type Description <code>genes</code> <code>dict[str, Genemsa]</code> <p>The msa object for each gene</p> Source code in <code>pyhlamsa/gene_family/cyp.py</code> <pre><code>class CYPmsa(Familymsa):\n    \"\"\"\n    A CYP interface that read MSA from fasta and haplotypes.tsv\n\n    Attributes:\n        genes (dict[str, Genemsa]): The msa object for each gene\n    \"\"\"\n\n    def __init__(\n        self,\n        genes: GeneSet = None,\n        filetype: TypeSet = [],\n        pharmvar_folder: str = \"\",\n        version: str = \"5.2.2\",\n    ):\n        \"\"\"\n        Args:\n            genes (str | list[str]): A list of genes you want to read.\n\n                Set None if you want read all gene in HLA\n\n            filetype: Ignore\n\n            pharmvar_folder (str): Path to your pharmvar folder\n\n                You should manually download &lt;https://www.pharmvar.org/download&gt;\n                and unzip it.\n\n            version (str): PharmVar version you want to download\n\n                Not works now\n        \"\"\"\n        if not pharmvar_folder:\n            pharmvar_folder = f\"pharmvar-{version}\"\n        super().__init__(genes, filetype, db_folder=pharmvar_folder, version=version)\n\n    def _download_db(self, version: str = \"\") -&gt; None:\n        \"\"\"\n        Download the CYP from https://www.pharmvar.org/download\n        \"\"\"\n        raise ValueError(\n            \"You should download CYP genes from https://www.pharmvar.org/download\"\n        )\n\n    def list_db_gene(self, filetype: TypeSet = []) -&gt; list[str]:\n        \"\"\"List the gene in folder\"\"\"\n        return sorted(os.listdir(self.db_folder))\n\n    def read_db_gene(self, gene: str, filetype: TypeSet = []) -&gt; Genemsa:\n        \"\"\"\n        Read `{gene}/{gene}.haplotypes.fasta` and `{gene}/{gene}.haplotypes.tsv`\n\n        `filetype` will be ignored now\n        \"\"\"\n        # read fasta\n        ref_seqs = {}\n        for seq in SeqIO.parse(\n            f\"{self.db_folder}/{gene}/{gene}.haplotypes.fasta\", \"fasta\"\n        ):\n            # split allele name\n            # e.g.  rs75017182, rs56038477 PV01077 NG_008807.2 PharmVar Version:5.1.10\n            for name in seq.description.replace(\", \", \",\").split(\" \")[0].split(\",\"):\n                ref_seqs[name.strip()] = str(seq.seq)\n        self.logger.debug(f\"Read sequence {ref_seqs.keys()}\")\n\n        # read tsv\n        # split by '\\t' and ignore header\n        var_text = open(glob(f\"{self.db_folder}/{gene}/RefSeqGene/*.haplotypes.tsv\")[0])\n        table = [i.strip().split(\"\\t\") for i in var_text if not i.startswith(\"#\")][1:]\n\n        # Get Reference sequence\n        reference_seq = None\n        reference_name = None\n        for i in table:\n            if i[0] not in ref_seqs:\n                continue\n            if i[3] == \"REFERENCE\" and ref_seqs[i[0]][0]:\n                if reference_seq:\n                    assert reference_seq == ref_seqs[i[0]]\n                    continue\n                reference_name = i[0]\n                reference_seq = ref_seqs[reference_name]\n        if not reference_seq:\n            # hard-coded for DPYD, because it's reference `NG_008807.2` is missing\n            if gene == \"DPYD\":\n                reference_name = \"rs111858276\"\n                reference_seq = ref_seqs[reference_name]\n                reference_seq = (\n                    reference_seq[: 376460 - 1] + \"A\" + reference_seq[376460:]\n                )\n            else:\n                raise ValueError(f\"Not reference found in {gene}\")\n\n        assert reference_name is not None\n        # Fill with Reference and reference is the first one\n        alleles = {reference_name: \"\"}\n        alleles.update(\n            {allele_name: reference_seq for allele_name in set(i[0] for i in table)}\n        )\n        self.logger.debug(f\"Read vcf {alleles.keys()}\")\n\n        # Remove duplciate\n        # in 5.1.10, there exist two same row\n        # CYP2D6*149  CYP2D6  rs59421388  NG_008376.4 8203    8203    G   A   substitution\n        # CYP2D6*149  CYP2D6  rs59421388  NG_008376.4 8203    8203    G   A   substitution\n        table_unique1 = filter(lambda i: i[3] != \"REFERENCE\", table)\n        table_unique2 = cast(tuple, map(tuple, table_unique1))  # type: ignore\n        table_unique = cast(list, map(list, set(list(table_unique2))))  # type: ignore\n\n        # Reconstruct msa from VCF variant\n        # VCF type: substitution and deleteion, insertion\n        # Table Header: ['Haplotype Name', 'Gene', 'rsID', 'ReferenceSequence',\n        #   'Variant Start', 'Variant Stop', 'Reference Allele', 'Variant Allele', 'Type']\n        # Insertion will move the index, so insert from last position first\n        for i in sorted(table_unique, key=lambda i: -int(i[4])):\n            if i[8] == \"substitution\":\n                pos = int(i[4]) - 1\n                end = pos + 1\n            elif i[8] == \"deletion\":\n                pos = int(i[4]) - 1\n                end = pos + len(i[6])\n                i[7] = \"-\" * len(i[6])\n            elif i[8] == \"insertion\":\n                # hard coded bugs\n                if i[0].startswith(\"CYP2A6*31\"):\n                    # CYP2A6*31.001   4530    4552    CCCCTTCCTGAGACCCTTAACCC -   deletion\n                    # CYP2A6*31.001   4530    4531    -   AATCCATATGTGGAATCTG insertion\n                    continue\n                if i[0].startswith(\"CYP2A6*27\"):\n                    # CYP2A6*27.001   7183    7184    -   A   insertion\n                    continue\n\n                pos = int(i[4])\n                end = int(i[4]) + len(i[7])\n                i[6] = \"-\" * len(i[7])\n                # check the gap is already inserted by others\n                # if false: insert '-' for all alleles\n                # else: replace the '-' with insertion seq\n                if set(alleles[i[0]][pos:end]) != set(\"-\"):\n                    for allele_name in alleles:\n                        alleles[allele_name] = (\n                            alleles[allele_name][:pos]\n                            + i[6]\n                            + alleles[allele_name][pos:]\n                        )\n            else:\n                raise ValueError(f\"Unknown Type {i[8]}\")\n\n            assert alleles[i[0]][pos:end] == i[6]\n            alleles[i[0]] = alleles[i[0]][:pos] + i[7] + alleles[i[0]][end:]\n\n        # split allele name (alleles.key() will change)\n        # e.g. rs75017182, rs56038477  DPYD    rs75017182  NG_008807.2 346167\n        for allele_name in list(alleles.keys()):\n            if \", \" in allele_name:\n                for an in allele_name.split(\",\"):\n                    alleles[an.strip()] = alleles[allele_name]\n                del alleles[allele_name]\n\n        # double check\n        length = None\n        for allele_name in alleles:\n            if length is None:\n                length = len(alleles[allele_name])\n            else:\n                assert length == len(alleles[allele_name])\n            if alleles[allele_name].replace(\"-\", \"\") != ref_seqs[allele_name]:\n                raise ValueError(f\"{allele_name} is not same as reference\")\n\n        assert length\n        msa = Genemsa(gene)\n        msa.alleles = alleles\n        msa.blocks = [BlockInfo(length=length)]\n        return msa.assume_label(\"other\")\n</code></pre>"},{"location":"#pyhlamsa.gene_family.cyp.CYPmsa.__getitem__","title":"<code>__getitem__(self, index: str) -&gt; Genemsa</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene_family/cyp.py</code> <pre><code>def __getitem__(self, index: str) -&gt; Genemsa:\n    \"\"\"Get specific gene's msa\"\"\"\n    return self.genes[index]\n</code></pre>"},{"location":"#pyhlamsa.gene_family.cyp.CYPmsa.__init__","title":"<code>__init__(self, genes: Union[str, Iterable[str]] = None, filetype: Union[str, Iterable[str]] = [], pharmvar_folder: str = '', version: str = '5.2.2')</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>genes</code> <code>str | list[str]</code> <p>A list of genes you want to read.</p> <p>Set None if you want read all gene in HLA</p> <code>None</code> <code>filetype</code> <code>Union[str, Iterable[str]]</code> <p>Ignore</p> <code>[]</code> <code>pharmvar_folder</code> <code>str</code> <p>Path to your pharmvar folder</p> <p>You should manually download https://www.pharmvar.org/download and unzip it.</p> <code>''</code> <code>version</code> <code>str</code> <p>PharmVar version you want to download</p> <p>Not works now</p> <code>'5.2.2'</code> Source code in <code>pyhlamsa/gene_family/cyp.py</code> <pre><code>def __init__(\n    self,\n    genes: GeneSet = None,\n    filetype: TypeSet = [],\n    pharmvar_folder: str = \"\",\n    version: str = \"5.2.2\",\n):\n    \"\"\"\n    Args:\n        genes (str | list[str]): A list of genes you want to read.\n\n            Set None if you want read all gene in HLA\n\n        filetype: Ignore\n\n        pharmvar_folder (str): Path to your pharmvar folder\n\n            You should manually download &lt;https://www.pharmvar.org/download&gt;\n            and unzip it.\n\n        version (str): PharmVar version you want to download\n\n            Not works now\n    \"\"\"\n    if not pharmvar_folder:\n        pharmvar_folder = f\"pharmvar-{version}\"\n    super().__init__(genes, filetype, db_folder=pharmvar_folder, version=version)\n</code></pre>"},{"location":"#pyhlamsa.gene_family.cyp.CYPmsa.__iter__","title":"<code>__iter__(self) -&gt; Iterable[str]</code>  <code>inherited</code> <code>special</code>","text":"Source code in <code>pyhlamsa/gene_family/cyp.py</code> <pre><code>def __iter__(self) -&gt; Iterable[str]:\n    \"\"\"Iter gene name like iter(dict)\"\"\"\n    return iter(self.genes)\n</code></pre>"},{"location":"#pyhlamsa.gene_family.cyp.CYPmsa.items","title":"<code>items(self) -&gt; Iterable[tuple[str, pyhlamsa.gene.genemsa.Genemsa]]</code>  <code>inherited</code>","text":"<p>list gene name and msa like dict.items()</p> Source code in <code>pyhlamsa/gene_family/cyp.py</code> <pre><code>def items(self) -&gt; Iterable[tuple[str, Genemsa]]:\n    \"\"\"list gene name and msa like dict.items()\"\"\"\n    return self.genes.items()\n</code></pre>"},{"location":"#pyhlamsa.gene_family.cyp.CYPmsa.list_db_gene","title":"<code>list_db_gene(self, filetype: Union[str, Iterable[str]] = []) -&gt; list</code>","text":"<p>List the gene in folder</p> Source code in <code>pyhlamsa/gene_family/cyp.py</code> <pre><code>def list_db_gene(self, filetype: TypeSet = []) -&gt; list[str]:\n    \"\"\"List the gene in folder\"\"\"\n    return sorted(os.listdir(self.db_folder))\n</code></pre>"},{"location":"#pyhlamsa.gene_family.cyp.CYPmsa.list_genes","title":"<code>list_genes(self) -&gt; list</code>  <code>inherited</code>","text":"<p>List all the gene's name in this family</p> Source code in <code>pyhlamsa/gene_family/cyp.py</code> <pre><code>def list_genes(self) -&gt; list[str]:\n    \"\"\"List all the gene's name in this family\"\"\"\n    return list(self.genes.keys())\n</code></pre>"},{"location":"#pyhlamsa.gene_family.cyp.CYPmsa.read_db_gene","title":"<code>read_db_gene(self, gene: str, filetype: Union[str, Iterable[str]] = []) -&gt; Genemsa</code>","text":"<p>Read <code>{gene}/{gene}.haplotypes.fasta</code> and <code>{gene}/{gene}.haplotypes.tsv</code></p> <p><code>filetype</code> will be ignored now</p> Source code in <code>pyhlamsa/gene_family/cyp.py</code> <pre><code>def read_db_gene(self, gene: str, filetype: TypeSet = []) -&gt; Genemsa:\n    \"\"\"\n    Read `{gene}/{gene}.haplotypes.fasta` and `{gene}/{gene}.haplotypes.tsv`\n\n    `filetype` will be ignored now\n    \"\"\"\n    # read fasta\n    ref_seqs = {}\n    for seq in SeqIO.parse(\n        f\"{self.db_folder}/{gene}/{gene}.haplotypes.fasta\", \"fasta\"\n    ):\n        # split allele name\n        # e.g.  rs75017182, rs56038477 PV01077 NG_008807.2 PharmVar Version:5.1.10\n        for name in seq.description.replace(\", \", \",\").split(\" \")[0].split(\",\"):\n            ref_seqs[name.strip()] = str(seq.seq)\n    self.logger.debug(f\"Read sequence {ref_seqs.keys()}\")\n\n    # read tsv\n    # split by '\\t' and ignore header\n    var_text = open(glob(f\"{self.db_folder}/{gene}/RefSeqGene/*.haplotypes.tsv\")[0])\n    table = [i.strip().split(\"\\t\") for i in var_text if not i.startswith(\"#\")][1:]\n\n    # Get Reference sequence\n    reference_seq = None\n    reference_name = None\n    for i in table:\n        if i[0] not in ref_seqs:\n            continue\n        if i[3] == \"REFERENCE\" and ref_seqs[i[0]][0]:\n            if reference_seq:\n                assert reference_seq == ref_seqs[i[0]]\n                continue\n            reference_name = i[0]\n            reference_seq = ref_seqs[reference_name]\n    if not reference_seq:\n        # hard-coded for DPYD, because it's reference `NG_008807.2` is missing\n        if gene == \"DPYD\":\n            reference_name = \"rs111858276\"\n            reference_seq = ref_seqs[reference_name]\n            reference_seq = (\n                reference_seq[: 376460 - 1] + \"A\" + reference_seq[376460:]\n            )\n        else:\n            raise ValueError(f\"Not reference found in {gene}\")\n\n    assert reference_name is not None\n    # Fill with Reference and reference is the first one\n    alleles = {reference_name: \"\"}\n    alleles.update(\n        {allele_name: reference_seq for allele_name in set(i[0] for i in table)}\n    )\n    self.logger.debug(f\"Read vcf {alleles.keys()}\")\n\n    # Remove duplciate\n    # in 5.1.10, there exist two same row\n    # CYP2D6*149  CYP2D6  rs59421388  NG_008376.4 8203    8203    G   A   substitution\n    # CYP2D6*149  CYP2D6  rs59421388  NG_008376.4 8203    8203    G   A   substitution\n    table_unique1 = filter(lambda i: i[3] != \"REFERENCE\", table)\n    table_unique2 = cast(tuple, map(tuple, table_unique1))  # type: ignore\n    table_unique = cast(list, map(list, set(list(table_unique2))))  # type: ignore\n\n    # Reconstruct msa from VCF variant\n    # VCF type: substitution and deleteion, insertion\n    # Table Header: ['Haplotype Name', 'Gene', 'rsID', 'ReferenceSequence',\n    #   'Variant Start', 'Variant Stop', 'Reference Allele', 'Variant Allele', 'Type']\n    # Insertion will move the index, so insert from last position first\n    for i in sorted(table_unique, key=lambda i: -int(i[4])):\n        if i[8] == \"substitution\":\n            pos = int(i[4]) - 1\n            end = pos + 1\n        elif i[8] == \"deletion\":\n            pos = int(i[4]) - 1\n            end = pos + len(i[6])\n            i[7] = \"-\" * len(i[6])\n        elif i[8] == \"insertion\":\n            # hard coded bugs\n            if i[0].startswith(\"CYP2A6*31\"):\n                # CYP2A6*31.001   4530    4552    CCCCTTCCTGAGACCCTTAACCC -   deletion\n                # CYP2A6*31.001   4530    4531    -   AATCCATATGTGGAATCTG insertion\n                continue\n            if i[0].startswith(\"CYP2A6*27\"):\n                # CYP2A6*27.001   7183    7184    -   A   insertion\n                continue\n\n            pos = int(i[4])\n            end = int(i[4]) + len(i[7])\n            i[6] = \"-\" * len(i[7])\n            # check the gap is already inserted by others\n            # if false: insert '-' for all alleles\n            # else: replace the '-' with insertion seq\n            if set(alleles[i[0]][pos:end]) != set(\"-\"):\n                for allele_name in alleles:\n                    alleles[allele_name] = (\n                        alleles[allele_name][:pos]\n                        + i[6]\n                        + alleles[allele_name][pos:]\n                    )\n        else:\n            raise ValueError(f\"Unknown Type {i[8]}\")\n\n        assert alleles[i[0]][pos:end] == i[6]\n        alleles[i[0]] = alleles[i[0]][:pos] + i[7] + alleles[i[0]][end:]\n\n    # split allele name (alleles.key() will change)\n    # e.g. rs75017182, rs56038477  DPYD    rs75017182  NG_008807.2 346167\n    for allele_name in list(alleles.keys()):\n        if \", \" in allele_name:\n            for an in allele_name.split(\",\"):\n                alleles[an.strip()] = alleles[allele_name]\n            del alleles[allele_name]\n\n    # double check\n    length = None\n    for allele_name in alleles:\n        if length is None:\n            length = len(alleles[allele_name])\n        else:\n            assert length == len(alleles[allele_name])\n        if alleles[allele_name].replace(\"-\", \"\") != ref_seqs[allele_name]:\n            raise ValueError(f\"{allele_name} is not same as reference\")\n\n    assert length\n    msa = Genemsa(gene)\n    msa.alleles = alleles\n    msa.blocks = [BlockInfo(length=length)]\n    return msa.assume_label(\"other\")\n</code></pre>"}]}